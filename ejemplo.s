.data
str_lit_0: .asciz "  ["
.Lfmt_int: .asciz "%d"
.Lfmt_ptr_debug: .asciz "DEBUG ptr=0x%lx\n"
str_lit_1: .asciz ", "
str_lit_2: .asciz "]"
newline_3: .asciz "\n"
str_lit_4: .asciz "=== SISTEMA DE ANALISIS DE DATOS ACADEMICOS ==="
newline_5: .asciz "\n"
str_lit_6: .asciz "\n--- DECLARACION DE MATRICES 2D ---"
newline_7: .asciz "\n"
str_lit_8: .asciz "Matrices 2D declaradas exitosamente:"
newline_9: .asciz "\n"
str_lit_10: .asciz "- calificacionesPorMateria: "
str_lit_11: .asciz " x "
newline_12: .asciz "\n"
str_lit_13: .asciz "- promediosPorSemestre: "
str_lit_14: .asciz " x "
newline_15: .asciz "\n"
str_lit_16: .asciz "- matrizA: "
str_lit_17: .asciz " x "
newline_18: .asciz "\n"
str_lit_19: .asciz "- matrizB: "
str_lit_20: .asciz " x "
newline_21: .asciz "\n"
str_lit_22: .asciz "\n--- DECLARACION DE MATRICES 3D ---"
newline_23: .asciz "\n"
str_lit_24: .asciz "Matrices 3D declaradas exitosamente:"
newline_25: .asciz "\n"
str_lit_26: .asciz "- evaluacionesDetalladas: "
str_lit_27: .asciz " x "
str_lit_28: .asciz " x "
newline_29: .asciz "\n"
str_lit_30: .asciz "- temperaturasPorDia: "
str_lit_31: .asciz " x "
str_lit_32: .asciz " x "
newline_33: .asciz "\n"
str_lit_34: .asciz "\n--- MODIFICACION DE ELEMENTOS 2D ---"
newline_35: .asciz "\n"
str_lit_36: .asciz "Calificación original del Estudiante 1 en Física: "
newline_37: .asciz "\n"
str_lit_38: .asciz "Nueva calificación del Estudiante 1 en Física: "
newline_39: .asciz "\n"
str_lit_40: .asciz "Modificaciones adicionales realizadas en otras posiciones"
newline_41: .asciz "\n"
double_lit_42: .double 85.5
double_lit_43: .double 87.200000000000003
double_lit_44: .double 89.099999999999994
double_lit_45: .double 90.299999999999997
double_lit_46: .double 88.700000000000003
double_lit_47: .double 91.200000000000003
str_lit_48: .asciz "Matriz de promedios por semestre inicializada"
newline_49: .asciz "\n"
str_lit_50: .asciz "\n--- MODIFICACION DE ELEMENTOS 3D ---"
newline_51: .asciz "\n"
str_lit_52: .asciz "Cubo de evaluaciones detalladas inicializado:"
newline_53: .asciz "\n"
str_lit_54: .asciz "- Estudiante 1, Matemáticas: ["
str_lit_55: .asciz ", "
str_lit_56: .asciz ", "
str_lit_57: .asciz "]"
newline_58: .asciz "\n"
str_lit_59: .asciz "- Estudiante 4, Biología: ["
str_lit_60: .asciz ", "
str_lit_61: .asciz ", "
str_lit_62: .asciz "]"
newline_63: .asciz "\n"
double_lit_64: .double 25.5
double_lit_65: .double 21.800000000000001
str_lit_66: .asciz "Temperaturas específicas modificadas"
newline_67: .asciz "\n"
str_lit_68: .asciz "\n--- ACCESO A ELEMENTOS 2D ---"
newline_69: .asciz "\n"
str_lit_70: .asciz "Matemáticas"
str_lit_71: .asciz "Física"
str_lit_72: .asciz "Química"
str_lit_73: .asciz "Biología"
str_lit_74: .asciz "Ana"
str_lit_75: .asciz "Luis"
str_lit_76: .asciz "María"
str_lit_77: .asciz "Carlos"
str_lit_78: .asciz "Análisis de calificaciones por estudiante:"
newline_79: .asciz "\n"
str_lit_80: .asciz "Estudiante "
str_lit_81: .asciz ":"
newline_82: .asciz "\n"
str_lit_83: .asciz "  "
str_lit_84: .asciz ": "
newline_85: .asciz "\n"
str_lit_86: .asciz "  Promedio: "
newline_87: .asciz "\n"
newline_88: .asciz "\n"
str_lit_89: .asciz "Acceso directo a elementos específicos:"
newline_90: .asciz "\n"
str_lit_91: .asciz "Primera calificación (Ana, Matemáticas): "
newline_92: .asciz "\n"
str_lit_93: .asciz "Última calificación (Carlos, Biología): "
newline_94: .asciz "\n"
str_lit_95: .asciz "Elemento central: "
newline_96: .asciz "\n"
str_lit_97: .asciz "\n--- ACCESO A ELEMENTOS 3D ---"
newline_98: .asciz "\n"
str_lit_99: .asciz "Análisis de evaluaciones detalladas:"
newline_100: .asciz "\n"
str_lit_101: .asciz "Examen 1"
str_lit_102: .asciz "Examen 2"
str_lit_103: .asciz "Proyecto"
str_lit_104: .asciz "Estudiante "
str_lit_105: .asciz ":"
newline_106: .asciz "\n"
str_lit_107: .asciz "  "
str_lit_108: .asciz ":"
newline_109: .asciz "\n"
str_lit_110: .asciz "    "
str_lit_111: .asciz ": "
newline_112: .asciz "\n"
newline_113: .asciz "\n"
str_lit_114: .asciz "Temperaturas registradas:"
newline_115: .asciz "\n"
str_lit_116: .asciz "Semana 1"
str_lit_117: .asciz "Semana 2"
str_lit_118: .asciz "Lunes"
str_lit_119: .asciz "Martes"
str_lit_120: .asciz "Miércoles"
str_lit_121: .asciz "Mañana"
str_lit_122: .asciz "Tarde"
str_lit_123: .asciz "Noche"
str_lit_124: .asciz ":"
newline_125: .asciz "\n"
str_lit_126: .asciz "  "
str_lit_127: .asciz ":"
newline_128: .asciz "\n"
str_lit_129: .asciz "    "
str_lit_130: .asciz ": "
str_lit_131: .asciz "°C"
newline_132: .asciz "\n"
str_lit_133: .asciz "\n--- OPERACIONES CON MATRICES ---"
newline_134: .asciz "\n"
str_lit_135: .asciz "Matriz A:"
newline_136: .asciz "\n"
str_lit_137: .asciz "Matriz B:"
newline_138: .asciz "\n"
str_lit_139: .asciz "Suma A + B:"
newline_140: .asciz "\n"
str_lit_141: .asciz "Producto A * B:"
newline_142: .asciz "\n"
str_lit_143: .asciz "Verificando operaciones:"
newline_144: .asciz "\n"
str_lit_145: .asciz "- Suma completada correctamente"
newline_146: .asciz "\n"
str_lit_147: .asciz "- Multiplicación completada correctamente"
newline_148: .asciz "\n"
str_lit_149: .asciz "\n--- TRANSPUESTA DE MATRIZ ---"
newline_150: .asciz "\n"
str_lit_151: .asciz "Matriz original (3x4):"
newline_152: .asciz "\n"
str_lit_153: .asciz "Matriz transpuesta (4x3):"
newline_154: .asciz "\n"
str_lit_155: .asciz "Transpuesta de matriz A:"
newline_156: .asciz "\n"
str_lit_157: .asciz "Doble transpuesta de A (debe ser igual a A original):"
newline_158: .asciz "\n"
str_lit_159: .asciz "\n--- CALCULO DE DETERMINANTES ---"
newline_160: .asciz "\n"
str_lit_161: .asciz "Matriz 2x2:"
newline_162: .asciz "\n"
str_lit_163: .asciz "Determinante 2x2: "
newline_164: .asciz "\n"
str_lit_165: .asciz "\nSegunda matriz 2x2:"
newline_166: .asciz "\n"
str_lit_167: .asciz "Determinante 2x2: "
newline_168: .asciz "\n"
str_lit_169: .asciz "\nMatriz A (3x3):"
newline_170: .asciz "\n"
str_lit_171: .asciz "Determinante 3x3 de matriz A: "
newline_172: .asciz "\n"
str_lit_173: .asciz "\nMatriz especial 3x3:"
newline_174: .asciz "\n"
str_lit_175: .asciz "Determinante 3x3: "
newline_176: .asciz "\n"
str_lit_177: .asciz "\n=== ANALISIS DE DATOS ACADEMICOS COMPLETADO ==="
newline_178: .asciz "\n"

.text
.global main
.extern printf
.extern print_string
.extern concat_string_string
.extern format_float
.extern format_int
.extern malloc
.extern calloc
.extern free
.extern snprintf
.extern exit


mostrarMatriz:
    sub sp, sp, #368              // Reservar frame completo
    stp x29, x30, [sp]           // Guardar FP y LR
    mov x29, sp                  // Setup frame pointer (base)
    // Guardar registros callee-saved (x19-x28)
    stp x19, x20, [sp, #16]      // Guardar x19, x20
    stp x21, x22, [sp, #32]      // Guardar x21, x22
    stp x23, x24, [sp, #48]      // Guardar x23, x24
    stp x25, x26, [sp, #64]      // Guardar x25, x26
    stp x27, x28, [sp, #80]      // Guardar x27, x28

    // Parametros recibidos en registros
    // matriz: matriz ptr recibido en x0, preservando en stack
    str x0, [x29, #96]

    // Inicialización del for
    #  Función para mostrar matriz 2D
    #  Función para sumar matrices
    #  Función para multiplicar matrices
    #  Función para calcular transpuesta
    #  Función para calcular determinante 2x2
    #  det = ad - bc para matriz [[a,b],[c,d]]
    #  Función para calcular determinante 3x3
    #  Expansión por la primera fila
    #  Menores 2x2
    #  Declaración dos dimensiones
    #  Declaración con inicialización directa
    #  Estudiante 1: Mat, Fis, Qui, Bio
    #  Estudiante 2
    #  Estudiante 3
    #  Estudiante 4
    #  Declaración con dimensiones específicas
    #  4 estudiantes, 6 semestres
    #  Matriz para operaciones matemáticas
    #  Declaración tres dimensiones
    #  Cubo de calificaciones: [estudiante][materia][evaluacion]
    #  4 estudiantes, 4 materias, 3 evaluaciones
    #  Cubo con datos inicializados
    #  Semana 1
    #  Lunes: mañana, tarde, noche
    #  Martes
    #  Miércoles
    #  Semana 2
    #  Lunes
    #  Martes
    #  Miércoles
    #  Modificación de un elemento dos dimensiones
    #  Modificar calificaciones específicas
    #  Estudiante 1, Física
    #  Estudiante 3, Matemáticas
    #  Estudiante 4, Química
    #  Llenar matriz de promedios
    #  Modificación de un elemento tres dimensiones
    #  Llenar cubo de evaluaciones detalladas
    #  Estudiante 1, Matemáticas, todas las evaluaciones
    #  Examen 1
    #  Examen 2
    #  Proyecto final
    #  Estudiante 2, Física, todas las evaluaciones  
    #  Estudiante 3, Química, todas las evaluaciones
    #  Estudiante 4, Biología, todas las evaluaciones
    #  Modificar temperaturas específicas
    #  Semana 1, Martes, Noche
    #  Semana 2, Lunes, Tarde
    #  Acceso a elementos dos dimensiones
    #  Acceso a elementos específicos
    #  Acceso a elementos tres dimensiones
    #  Solo primeros 2 estudiantes para brevedad
    #  Solo primeras 2 materias
    #  Solo mostrar si tiene valor asignado
    #  Análisis de temperaturas
    #  Operaciones con matrices
    #  Suma de matrices
    #  Multiplicación de matrices
    #  Verificar propiedades
    #  Transpuesta de matriz
    #  Matriz rectangular para demostrar transpuesta
    #  Transpuesta de matriz cuadrada
    #  Verificar propiedad: (A^T)^T = A
    #  Determinante 2x2 y 3x3
    #  Determinante 2x2
    #  Otro ejemplo 2x2
    #  Determinante 3x3
    #  Otra matriz 3x3
    mov w19, #0
    str w19, [x29, #104]      // Guardar int 'i' en stack
for_start_0:  // Inicio del for
    ldr w19, [x29, #104]
    str w19, [sp, #-16]!         // Guardar primer operando en stack
    ldr x20, [x29, #96]      // Cargar puntero del array 'matriz' desde stack
    // Array.length: cargar longitud del array
    ldr w19, [x20, #0]        // longitud = array[0] (4 bytes)
    ldr w20, [sp], #16           // Restaurar primer operando desde stack
    // Comparación INT: w20 < w19 usando runtime C
    mov w0, w20
    mov w1, w19
    bl cmp_int_lt
    // Convertir resultado string a booleano
    bl string_to_boolean
    // w0 ahora contiene 0 (false) o 1 (true)
    cbz w0, for_end_0  // Si condición es falsa, salir del for
    adrp x19, str_lit_0
    add x19, x19, :lo12:str_lit_0
    str x19, [x29, #112]      // Guardar string 'fila' en stack
    // Inicialización del for
    mov w19, #0
    str w19, [x29, #120]      // Guardar int 'j' en stack
for_start_1:  // Inicio del for
    ldr w19, [x29, #120]
    str w19, [sp, #-16]!         // Guardar primer operando en stack
    // Cargar puntero del array desde stack
    ldr x19, [x29, #96]      // cargar puntero del array desde stack
    str x19, [sp, #-16]!  // Preservar puntero vector antes de evaluar índice
    ldr w19, [x29, #104]
    ldr x20, [sp], #16  // Restaurar puntero del vector desde stack
    // Acceso a matriz: matriz[index] retorna puntero
    add x22, x20, #8             // saltar header (4) + padding (4)
    add x22, x22, w19, uxtw #3   // calcular dirección: matriz + index * 8
    ldr x21, [x22]               // cargar puntero del sub-array
    // Array.length: cargar longitud del array
    ldr w19, [x21, #0]        // longitud = array[0] (4 bytes)
    ldr w20, [sp], #16           // Restaurar primer operando desde stack
    // Comparación INT: w20 < w19 usando runtime C
    mov w0, w20
    mov w1, w19
    bl cmp_int_lt
    // Convertir resultado string a booleano
    bl string_to_boolean
    // w0 ahora contiene 0 (false) o 1 (true)
    cbz w0, for_end_1  // Si condición es falsa, salir del for
    ldr x19, [x29, #112]
    mov x0, x19
    str x0, [sp, #-16]!
    // Cargar puntero de matriz desde stack
    ldr x19, [x29, #96]
    str x19, [sp, #-16]!  // Preservar puntero matriz antes de evaluar índice fila
    ldr w20, [x29, #104]
    ldr x19, [sp], #16  // Restaurar puntero matriz desde stack
    // Acceso a fila: fila_ptr = matriz[fila]
    add x21, x19, #8             // saltar header de longitud
    add x21, x21, w20, uxtw #3   // offset = fila * 8
    ldr x21, [x21]               // cargar puntero de fila
    str x21, [sp, #-16]!  // Preservar puntero fila antes de evaluar índice columna
    ldr w22, [x29, #120]
    ldr x21, [sp], #16  // Restaurar puntero fila desde stack
    // Acceso a elemento: resultado = fila[columna]
    add x23, x21, #8             // saltar header de fila
    add x23, x23, w22, uxtw #2   // addr = fila_ptr + columna * 4
    ldr w24, [x23]               // cargar elemento desde addr
    // String.valueOf() - Reservar buffer para resultado
    mov x0, #64                      // Tamaño del buffer
    bl malloc                         // Llamar a malloc
    str x0, [x29, #24]               // Guardar puntero al buffer en stack temporal (#24)
    // String.valueOf(int)
    ldr x0, [x29, #24]             // Cargar buffer desde stack
    mov x1, #64                   // tamaño del buffer
    adrp x2, .Lfmt_int            // Formato %d
    add x2, x2, :lo12:.Lfmt_int
    mov w3, w24                   // Valor int a convertir
    bl snprintf
    ldr x21, [x29, #24]             // Cargar buffer desde stack
    mov x19, x21                      // Mover resultado a x19
    mov x0, x19
    mov x1, x0
    ldr x0, [sp], #16
    // Concatenar string + string usando runtime C
    bl concat_string_string      // Llama a función C optimizada
    str x0, [x29, #112]      // Guardar string 'fila' en stack
    // ===== IF statement (label 0) =====
    ldr w19, [x29, #120]
    str w19, [sp, #-16]!         // Guardar primer operando en stack
    // Cargar puntero del array desde stack
    ldr x19, [x29, #96]      // cargar puntero del array desde stack
    str x19, [sp, #-16]!  // Preservar puntero vector antes de evaluar índice
    ldr w19, [x29, #104]
    ldr x20, [sp], #16  // Restaurar puntero del vector desde stack
    // Acceso a matriz: matriz[index] retorna puntero
    add x22, x20, #8             // saltar header (4) + padding (4)
    add x22, x22, w19, uxtw #3   // calcular dirección: matriz + index * 8
    ldr x21, [x22]               // cargar puntero del sub-array
    // Array.length: cargar longitud del array
    ldr w19, [x21, #0]        // longitud = array[0] (4 bytes)
    str w19, [x29, #128]  // Preservar operando izq resta (prof=0)
    mov w19, #1
    ldr w20, [x29, #128]  // Restaurar operando izq resta (prof=0) [colisión evitada]
    sub w21, w20, w19
    ldr w19, [sp], #16           // Restaurar primer operando desde stack
    // Comparación INT: w19 < w21 usando runtime C
    mov w0, w19
    mov w1, w21
    bl cmp_int_lt
    // Convertir resultado string a booleano
    bl string_to_boolean
    // w0 ahora contiene 0 (false) o 1 (true)
    cbz w0, .Lend_if_0          // Si false, ir al final
    ldr x19, [x29, #112]
    mov x0, x19
    str x0, [sp, #-16]!
    adrp x19, str_lit_1
    add x19, x19, :lo12:str_lit_1
    mov x0, x19
    mov x1, x0
    ldr x0, [sp], #16
    // Concatenar string + string usando runtime C
    bl concat_string_string      // Llama a función C optimizada
    str x0, [x29, #112]      // Guardar string 'fila' en stack
.Lend_if_0:                      // Fin del if
for_continue_1:  // Continue del for (actualización)
    // Actualización del for
    ldr w19, [x29, #120]
    str w19, [x29, #128]  // Preservar operando izq (prof=0)
    mov w20, #1
    ldr w19, [x29, #128]  // Restaurar operando izq (prof=0)
    add w21, w19, w20
    str w21, [x29, #120]      // Guardar int 'j' en stack
    b for_start_1  // Volver al inicio del for
for_end_1:  // Fin del for
    ldr x19, [x29, #112]
    mov x0, x19
    str x0, [sp, #-16]!
    adrp x19, str_lit_2
    add x19, x19, :lo12:str_lit_2
    mov x0, x19
    mov x1, x0
    ldr x0, [sp], #16
    // Concatenar string + string usando runtime C
    bl concat_string_string      // Llama a función C optimizada
    str x0, [x29, #112]      // Guardar string 'fila' en stack
    ldr x19, [x29, #112]
    mov x0, x19
    bl print_string
    adrp x0, newline_3
    add x0, x0, :lo12:newline_3
    bl print_string
for_continue_0:  // Continue del for (actualización)
    // Actualización del for
    ldr w19, [x29, #104]
    str w19, [x29, #128]  // Preservar operando izq (prof=0)
    mov w20, #1
    ldr w19, [x29, #128]  // Restaurar operando izq (prof=0)
    add w21, w19, w20
    str w21, [x29, #104]      // Guardar int 'i' en stack
    b for_start_0  // Volver al inicio del for
for_end_0:  // Fin del for
    // Restaurar registros callee-saved (x19-x28)
    ldp x19, x20, [sp, #16]      // Restaurar x19, x20
    ldp x21, x22, [sp, #32]      // Restaurar x21, x22
    ldp x23, x24, [sp, #48]      // Restaurar x23, x24
    ldp x25, x26, [sp, #64]      // Restaurar x25, x26
    ldp x27, x28, [sp, #80]      // Restaurar x27, x28
    mov sp, x29                  // Restaurar SP a la base
    ldp x29, x30, [sp], #16      // Restaurar FP/LR desde base
    ret                          // Retornar

sumarMatrices:
    sub sp, sp, #368              // Reservar frame completo
    stp x29, x30, [sp]           // Guardar FP y LR
    mov x29, sp                  // Setup frame pointer (base)
    // Guardar registros callee-saved (x19-x28)
    stp x19, x20, [sp, #16]      // Guardar x19, x20
    stp x21, x22, [sp, #32]      // Guardar x21, x22
    stp x23, x24, [sp, #48]      // Guardar x23, x24
    stp x25, x26, [sp, #64]      // Guardar x25, x26
    stp x27, x28, [sp, #80]      // Guardar x27, x28

    // Parametros recibidos en registros
    // a: matriz ptr recibido en x0, preservando en stack
    str x0, [x29, #96]
    // b: matriz ptr recibido en x1, preservando en stack
    str x1, [x29, #104]

    ldr x20, [x29, #96]      // Cargar puntero del array 'a' desde stack
    // Array.length: cargar longitud del array
    ldr w19, [x20, #0]        // longitud = array[0] (4 bytes)
    str w19, [x29, #112]      // Guardar int 'filas' en stack
    // Cargar puntero del array desde stack
    ldr x19, [x29, #96]      // cargar puntero del array desde stack
    str x19, [sp, #-16]!  // Preservar puntero vector antes de evaluar índice
    mov w19, #0
    ldr x20, [sp], #16  // Restaurar puntero del vector desde stack
    // Acceso a matriz: matriz[index] retorna puntero
    add x22, x20, #8             // saltar header (4) + padding (4)
    add x22, x22, w19, uxtw #3   // calcular dirección: matriz + index * 8
    ldr x21, [x22]               // cargar puntero del sub-array
    // Array.length: cargar longitud del array
    ldr w19, [x21, #0]        // longitud = array[0] (4 bytes)
    str w19, [x29, #120]      // Guardar int 'columnas' en stack
    ldr w19, [x29, #112]
    str w19, [x29, #128]  // Guardar dim[0] (filas)
    ldr w19, [x29, #120]
    str w19, [x29, #132]  // Guardar dim[1] (columnas)
    // Crear matriz 2D jerárquica
    mov x0, #2                // num_dimensiones = 2
    add x1, x29, #128          // puntero a dimensiones en stack
    mov x2, #2               // tipo_elemento
    mov x3, #4               // element_size
    bl create_multidim_array  // Llamar a función C helper
    mov x19, x0               // Guardar puntero resultante
    // Almacenar matriz en stack
    str x19, [x29, #136]
    // Inicialización del for
    mov w19, #0
    str w19, [x29, #152]      // Guardar int 'i' en stack
for_start_2:  // Inicio del for
    ldr w19, [x29, #152]
    str w19, [sp, #-16]!         // Guardar primer operando en stack
    ldr w20, [x29, #112]
    ldr w21, [sp], #16           // Restaurar primer operando desde stack
    // Comparación INT: w21 < w20 usando runtime C
    mov w0, w21
    mov w1, w20
    bl cmp_int_lt
    // Convertir resultado string a booleano
    bl string_to_boolean
    // w0 ahora contiene 0 (false) o 1 (true)
    cbz w0, for_end_2  // Si condición es falsa, salir del for
    // Inicialización del for
    mov w19, #0
    str w19, [x29, #160]      // Guardar int 'j' en stack
for_start_3:  // Inicio del for
    ldr w19, [x29, #160]
    str w19, [sp, #-16]!         // Guardar primer operando en stack
    ldr w20, [x29, #120]
    ldr w21, [sp], #16           // Restaurar primer operando desde stack
    // Comparación INT: w21 < w20 usando runtime C
    mov w0, w21
    mov w1, w20
    bl cmp_int_lt
    // Convertir resultado string a booleano
    bl string_to_boolean
    // w0 ahora contiene 0 (false) o 1 (true)
    cbz w0, for_end_3  // Si condición es falsa, salir del for
    // Cargar puntero de matriz desde stack para asignación
    ldr x19, [x29, #136]
    ldr w20, [x29, #152]
    // Obtener puntero de fila para asignación
    add x21, x19, #8             // saltar header de matriz
    add x21, x21, w20, uxtw #3   // offset = fila * 8
    ldr x21, [x21]               // cargar puntero de fila
    ldr w22, [x29, #160]
    // Cargar puntero de matriz desde stack
    ldr x23, [x29, #96]
    str x23, [sp, #-16]!  // Preservar puntero matriz antes de evaluar índice fila
    ldr w24, [x29, #152]
    ldr x23, [sp], #16  // Restaurar puntero matriz desde stack
    // Acceso a fila: fila_ptr = matriz[fila]
    add x25, x23, #8             // saltar header de longitud
    add x25, x25, w24, uxtw #3   // offset = fila * 8
    ldr x25, [x25]               // cargar puntero de fila
    str x25, [sp, #-16]!  // Preservar puntero fila antes de evaluar índice columna
    ldr w26, [x29, #160]
    ldr x25, [sp], #16  // Restaurar puntero fila desde stack
    // Acceso a elemento: resultado = fila[columna]
    add x27, x25, #8             // saltar header de fila
    add x27, x27, w26, uxtw #2   // addr = fila_ptr + columna * 4
    ldr w28, [x27]               // cargar elemento desde addr
    str w28, [x29, #168]  // Preservar operando izq (prof=0)
    // Cargar puntero de matriz desde stack
    ldr x23, [x29, #104]
    str x23, [sp, #-16]!  // Preservar puntero matriz antes de evaluar índice fila
    ldr w24, [x29, #152]
    ldr x23, [sp], #16  // Restaurar puntero matriz desde stack
    // Acceso a fila: fila_ptr = matriz[fila]
    add x25, x23, #8             // saltar header de longitud
    add x25, x25, w24, uxtw #3   // offset = fila * 8
    ldr x25, [x25]               // cargar puntero de fila
    str x25, [sp, #-16]!  // Preservar puntero fila antes de evaluar índice columna
    ldr w26, [x29, #160]
    ldr x25, [sp], #16  // Restaurar puntero fila desde stack
    // Acceso a elemento: resultado = fila[columna]
    add x27, x25, #8             // saltar header de fila
    add x27, x27, w26, uxtw #2   // addr = fila_ptr + columna * 4
    ldr w9, [x27]               // cargar elemento desde addr
    ldr w28, [x29, #168]  // Restaurar operando izq (prof=0)
    add w23, w28, w9
    // Asignación: fila[columna] = value
    add x24, x21, #8             // saltar header de fila
    add x24, x24, w22, uxtw #2   // addr = fila_ptr + columna * 4
    str w23, [x24]               // guardar valor
for_continue_3:  // Continue del for (actualización)
    // Actualización del for
    ldr w19, [x29, #160]
    str w19, [x29, #168]  // Preservar operando izq (prof=0)
    mov w20, #1
    ldr w19, [x29, #168]  // Restaurar operando izq (prof=0)
    add w21, w19, w20
    str w21, [x29, #160]      // Guardar int 'j' en stack
    b for_start_3  // Volver al inicio del for
for_end_3:  // Fin del for
for_continue_2:  // Continue del for (actualización)
    // Actualización del for
    ldr w19, [x29, #152]
    str w19, [x29, #168]  // Preservar operando izq (prof=0)
    mov w20, #1
    ldr w19, [x29, #168]  // Restaurar operando izq (prof=0)
    add w21, w19, w20
    str w21, [x29, #152]      // Guardar int 'i' en stack
    b for_start_2  // Volver al inicio del for
for_end_2:  // Fin del for
    ldr x19, [x29, #136]      // Cargar puntero del array 'resultado' desde stack
    mov x0, x19                 // Mover puntero a x0
    // Restaurar registros callee-saved (x19-x28)
    ldp x19, x20, [sp, #16]      // Restaurar x19, x20
    ldp x21, x22, [sp, #32]      // Restaurar x21, x22
    ldp x23, x24, [sp, #48]      // Restaurar x23, x24
    ldp x25, x26, [sp, #64]      // Restaurar x25, x26
    ldp x27, x28, [sp, #80]      // Restaurar x27, x28
    mov sp, x29                  // Restaurar SP a la base
    ldp x29, x30, [sp], #16      // Restaurar FP/LR desde base
    ret                          // Retornar

multiplicarMatrices:
    sub sp, sp, #368              // Reservar frame completo
    stp x29, x30, [sp]           // Guardar FP y LR
    mov x29, sp                  // Setup frame pointer (base)
    // Guardar registros callee-saved (x19-x28)
    stp x19, x20, [sp, #16]      // Guardar x19, x20
    stp x21, x22, [sp, #32]      // Guardar x21, x22
    stp x23, x24, [sp, #48]      // Guardar x23, x24
    stp x25, x26, [sp, #64]      // Guardar x25, x26
    stp x27, x28, [sp, #80]      // Guardar x27, x28

    // Parametros recibidos en registros
    // a: matriz ptr recibido en x0, preservando en stack
    str x0, [x29, #96]
    // b: matriz ptr recibido en x1, preservando en stack
    str x1, [x29, #104]

    ldr x20, [x29, #96]      // Cargar puntero del array 'a' desde stack
    // Array.length: cargar longitud del array
    ldr w19, [x20, #0]        // longitud = array[0] (4 bytes)
    str w19, [x29, #112]      // Guardar int 'filasA' en stack
    // Cargar puntero del array desde stack
    ldr x19, [x29, #96]      // cargar puntero del array desde stack
    str x19, [sp, #-16]!  // Preservar puntero vector antes de evaluar índice
    mov w19, #0
    ldr x20, [sp], #16  // Restaurar puntero del vector desde stack
    // Acceso a matriz: matriz[index] retorna puntero
    add x22, x20, #8             // saltar header (4) + padding (4)
    add x22, x22, w19, uxtw #3   // calcular dirección: matriz + index * 8
    ldr x21, [x22]               // cargar puntero del sub-array
    // Array.length: cargar longitud del array
    ldr w19, [x21, #0]        // longitud = array[0] (4 bytes)
    str w19, [x29, #120]      // Guardar int 'columnasA' en stack
    // Cargar puntero del array desde stack
    ldr x19, [x29, #104]      // cargar puntero del array desde stack
    str x19, [sp, #-16]!  // Preservar puntero vector antes de evaluar índice
    mov w19, #0
    ldr x20, [sp], #16  // Restaurar puntero del vector desde stack
    // Acceso a matriz: matriz[index] retorna puntero
    add x22, x20, #8             // saltar header (4) + padding (4)
    add x22, x22, w19, uxtw #3   // calcular dirección: matriz + index * 8
    ldr x21, [x22]               // cargar puntero del sub-array
    // Array.length: cargar longitud del array
    ldr w19, [x21, #0]        // longitud = array[0] (4 bytes)
    str w19, [x29, #128]      // Guardar int 'columnasB' en stack
    ldr w19, [x29, #112]
    str w19, [x29, #136]  // Guardar dim[0] (filas)
    ldr w19, [x29, #128]
    str w19, [x29, #140]  // Guardar dim[1] (columnas)
    // Crear matriz 2D jerárquica
    mov x0, #2                // num_dimensiones = 2
    add x1, x29, #136          // puntero a dimensiones en stack
    mov x2, #2               // tipo_elemento
    mov x3, #4               // element_size
    bl create_multidim_array  // Llamar a función C helper
    mov x19, x0               // Guardar puntero resultante
    // Almacenar matriz en stack
    str x19, [x29, #144]
    // Inicialización del for
    mov w19, #0
    str w19, [x29, #160]      // Guardar int 'i' en stack
for_start_4:  // Inicio del for
    ldr w19, [x29, #160]
    str w19, [sp, #-16]!         // Guardar primer operando en stack
    ldr w20, [x29, #112]
    ldr w21, [sp], #16           // Restaurar primer operando desde stack
    // Comparación INT: w21 < w20 usando runtime C
    mov w0, w21
    mov w1, w20
    bl cmp_int_lt
    // Convertir resultado string a booleano
    bl string_to_boolean
    // w0 ahora contiene 0 (false) o 1 (true)
    cbz w0, for_end_4  // Si condición es falsa, salir del for
    // Inicialización del for
    mov w19, #0
    str w19, [x29, #168]      // Guardar int 'j' en stack
for_start_5:  // Inicio del for
    ldr w19, [x29, #168]
    str w19, [sp, #-16]!         // Guardar primer operando en stack
    ldr w20, [x29, #128]
    ldr w21, [sp], #16           // Restaurar primer operando desde stack
    // Comparación INT: w21 < w20 usando runtime C
    mov w0, w21
    mov w1, w20
    bl cmp_int_lt
    // Convertir resultado string a booleano
    bl string_to_boolean
    // w0 ahora contiene 0 (false) o 1 (true)
    cbz w0, for_end_5  // Si condición es falsa, salir del for
    // Cargar puntero de matriz desde stack para asignación
    ldr x19, [x29, #144]
    ldr w20, [x29, #160]
    // Obtener puntero de fila para asignación
    add x21, x19, #8             // saltar header de matriz
    add x21, x21, w20, uxtw #3   // offset = fila * 8
    ldr x21, [x21]               // cargar puntero de fila
    ldr w22, [x29, #168]
    mov w23, #0
    // Asignación: fila[columna] = value
    add x24, x21, #8             // saltar header de fila
    add x24, x24, w22, uxtw #2   // addr = fila_ptr + columna * 4
    str w23, [x24]               // guardar valor
    // Inicialización del for
    mov w19, #0
    str w19, [x29, #176]      // Guardar int 'k' en stack
for_start_6:  // Inicio del for
    ldr w19, [x29, #176]
    str w19, [sp, #-16]!         // Guardar primer operando en stack
    ldr w20, [x29, #120]
    ldr w21, [sp], #16           // Restaurar primer operando desde stack
    // Comparación INT: w21 < w20 usando runtime C
    mov w0, w21
    mov w1, w20
    bl cmp_int_lt
    // Convertir resultado string a booleano
    bl string_to_boolean
    // w0 ahora contiene 0 (false) o 1 (true)
    cbz w0, for_end_6  // Si condición es falsa, salir del for
    // Cargar puntero de matriz desde stack para asignación
    ldr x19, [x29, #144]
    ldr w20, [x29, #160]
    // Obtener puntero de fila para asignación
    add x21, x19, #8             // saltar header de matriz
    add x21, x21, w20, uxtw #3   // offset = fila * 8
    ldr x21, [x21]               // cargar puntero de fila
    ldr w22, [x29, #168]
    // Cargar puntero de matriz desde stack
    ldr x23, [x29, #144]
    str x23, [sp, #-16]!  // Preservar puntero matriz antes de evaluar índice fila
    ldr w24, [x29, #160]
    ldr x23, [sp], #16  // Restaurar puntero matriz desde stack
    // Acceso a fila: fila_ptr = matriz[fila]
    add x25, x23, #8             // saltar header de longitud
    add x25, x25, w24, uxtw #3   // offset = fila * 8
    ldr x25, [x25]               // cargar puntero de fila
    str x25, [sp, #-16]!  // Preservar puntero fila antes de evaluar índice columna
    ldr w26, [x29, #168]
    ldr x25, [sp], #16  // Restaurar puntero fila desde stack
    // Acceso a elemento: resultado = fila[columna]
    add x27, x25, #8             // saltar header de fila
    add x27, x27, w26, uxtw #2   // addr = fila_ptr + columna * 4
    ldr w28, [x27]               // cargar elemento desde addr
    str w28, [x29, #184]  // Preservar operando izq (prof=0)
    // Cargar puntero de matriz desde stack
    ldr x23, [x29, #96]
    str x23, [sp, #-16]!  // Preservar puntero matriz antes de evaluar índice fila
    ldr w24, [x29, #160]
    ldr x23, [sp], #16  // Restaurar puntero matriz desde stack
    // Acceso a fila: fila_ptr = matriz[fila]
    add x25, x23, #8             // saltar header de longitud
    add x25, x25, w24, uxtw #3   // offset = fila * 8
    ldr x25, [x25]               // cargar puntero de fila
    str x25, [sp, #-16]!  // Preservar puntero fila antes de evaluar índice columna
    ldr w26, [x29, #176]
    ldr x25, [sp], #16  // Restaurar puntero fila desde stack
    // Acceso a elemento: resultado = fila[columna]
    add x27, x25, #8             // saltar header de fila
    add x27, x27, w26, uxtw #2   // addr = fila_ptr + columna * 4
    ldr w9, [x27]               // cargar elemento desde addr
    str w9, [x29, #200]  // Preservar operando izq mult (prof=1)
    // Cargar puntero de matriz desde stack
    ldr x23, [x29, #104]
    str x23, [sp, #-16]!  // Preservar puntero matriz antes de evaluar índice fila
    ldr w24, [x29, #176]
    ldr x23, [sp], #16  // Restaurar puntero matriz desde stack
    // Acceso a fila: fila_ptr = matriz[fila]
    add x25, x23, #8             // saltar header de longitud
    add x25, x25, w24, uxtw #3   // offset = fila * 8
    ldr x25, [x25]               // cargar puntero de fila
    str x25, [sp, #-16]!  // Preservar puntero fila antes de evaluar índice columna
    ldr w26, [x29, #168]
    ldr x25, [sp], #16  // Restaurar puntero fila desde stack
    // Acceso a elemento: resultado = fila[columna]
    add x27, x25, #8             // saltar header de fila
    add x27, x27, w26, uxtw #2   // addr = fila_ptr + columna * 4
    ldr w10, [x27]               // cargar elemento desde addr
    ldr w9, [x29, #200]  // Restaurar operando izq mult (prof=1)
    mul w23, w9, w10
    ldr w28, [x29, #184]  // Restaurar operando izq (prof=0)
    add w24, w28, w23
    // Asignación: fila[columna] = value
    add x23, x21, #8             // saltar header de fila
    add x23, x23, w22, uxtw #2   // addr = fila_ptr + columna * 4
    str w24, [x23]               // guardar valor
for_continue_6:  // Continue del for (actualización)
    // Actualización del for
    ldr w19, [x29, #176]
    str w19, [x29, #184]  // Preservar operando izq (prof=0)
    mov w20, #1
    ldr w19, [x29, #184]  // Restaurar operando izq (prof=0)
    add w21, w19, w20
    str w21, [x29, #176]      // Guardar int 'k' en stack
    b for_start_6  // Volver al inicio del for
for_end_6:  // Fin del for
for_continue_5:  // Continue del for (actualización)
    // Actualización del for
    ldr w19, [x29, #168]
    str w19, [x29, #184]  // Preservar operando izq (prof=0)
    mov w20, #1
    ldr w19, [x29, #184]  // Restaurar operando izq (prof=0)
    add w21, w19, w20
    str w21, [x29, #168]      // Guardar int 'j' en stack
    b for_start_5  // Volver al inicio del for
for_end_5:  // Fin del for
for_continue_4:  // Continue del for (actualización)
    // Actualización del for
    ldr w19, [x29, #160]
    str w19, [x29, #184]  // Preservar operando izq (prof=0)
    mov w20, #1
    ldr w19, [x29, #184]  // Restaurar operando izq (prof=0)
    add w21, w19, w20
    str w21, [x29, #160]      // Guardar int 'i' en stack
    b for_start_4  // Volver al inicio del for
for_end_4:  // Fin del for
    ldr x19, [x29, #144]      // Cargar puntero del array 'resultado' desde stack
    mov x0, x19                 // Mover puntero a x0
    // Restaurar registros callee-saved (x19-x28)
    ldp x19, x20, [sp, #16]      // Restaurar x19, x20
    ldp x21, x22, [sp, #32]      // Restaurar x21, x22
    ldp x23, x24, [sp, #48]      // Restaurar x23, x24
    ldp x25, x26, [sp, #64]      // Restaurar x25, x26
    ldp x27, x28, [sp, #80]      // Restaurar x27, x28
    mov sp, x29                  // Restaurar SP a la base
    ldp x29, x30, [sp], #16      // Restaurar FP/LR desde base
    ret                          // Retornar

calcularTranspuesta:
    sub sp, sp, #368              // Reservar frame completo
    stp x29, x30, [sp]           // Guardar FP y LR
    mov x29, sp                  // Setup frame pointer (base)
    // Guardar registros callee-saved (x19-x28)
    stp x19, x20, [sp, #16]      // Guardar x19, x20
    stp x21, x22, [sp, #32]      // Guardar x21, x22
    stp x23, x24, [sp, #48]      // Guardar x23, x24
    stp x25, x26, [sp, #64]      // Guardar x25, x26
    stp x27, x28, [sp, #80]      // Guardar x27, x28

    // Parametros recibidos en registros
    // matriz: matriz ptr recibido en x0, preservando en stack
    str x0, [x29, #96]

    ldr x20, [x29, #96]      // Cargar puntero del array 'matriz' desde stack
    // Array.length: cargar longitud del array
    ldr w19, [x20, #0]        // longitud = array[0] (4 bytes)
    str w19, [x29, #104]      // Guardar int 'filas' en stack
    // Cargar puntero del array desde stack
    ldr x19, [x29, #96]      // cargar puntero del array desde stack
    str x19, [sp, #-16]!  // Preservar puntero vector antes de evaluar índice
    mov w19, #0
    ldr x20, [sp], #16  // Restaurar puntero del vector desde stack
    // Acceso a matriz: matriz[index] retorna puntero
    add x22, x20, #8             // saltar header (4) + padding (4)
    add x22, x22, w19, uxtw #3   // calcular dirección: matriz + index * 8
    ldr x21, [x22]               // cargar puntero del sub-array
    // Array.length: cargar longitud del array
    ldr w19, [x21, #0]        // longitud = array[0] (4 bytes)
    str w19, [x29, #112]      // Guardar int 'columnas' en stack
    ldr w19, [x29, #112]
    str w19, [x29, #120]  // Guardar dim[0] (filas)
    ldr w19, [x29, #104]
    str w19, [x29, #124]  // Guardar dim[1] (columnas)
    // Crear matriz 2D jerárquica
    mov x0, #2                // num_dimensiones = 2
    add x1, x29, #120          // puntero a dimensiones en stack
    mov x2, #2               // tipo_elemento
    mov x3, #4               // element_size
    bl create_multidim_array  // Llamar a función C helper
    mov x19, x0               // Guardar puntero resultante
    // Almacenar matriz en stack
    str x19, [x29, #128]
    // Inicialización del for
    mov w19, #0
    str w19, [x29, #144]      // Guardar int 'i' en stack
for_start_7:  // Inicio del for
    ldr w19, [x29, #144]
    str w19, [sp, #-16]!         // Guardar primer operando en stack
    ldr w20, [x29, #104]
    ldr w21, [sp], #16           // Restaurar primer operando desde stack
    // Comparación INT: w21 < w20 usando runtime C
    mov w0, w21
    mov w1, w20
    bl cmp_int_lt
    // Convertir resultado string a booleano
    bl string_to_boolean
    // w0 ahora contiene 0 (false) o 1 (true)
    cbz w0, for_end_7  // Si condición es falsa, salir del for
    // Inicialización del for
    mov w19, #0
    str w19, [x29, #152]      // Guardar int 'j' en stack
for_start_8:  // Inicio del for
    ldr w19, [x29, #152]
    str w19, [sp, #-16]!         // Guardar primer operando en stack
    ldr w20, [x29, #112]
    ldr w21, [sp], #16           // Restaurar primer operando desde stack
    // Comparación INT: w21 < w20 usando runtime C
    mov w0, w21
    mov w1, w20
    bl cmp_int_lt
    // Convertir resultado string a booleano
    bl string_to_boolean
    // w0 ahora contiene 0 (false) o 1 (true)
    cbz w0, for_end_8  // Si condición es falsa, salir del for
    // Cargar puntero de matriz desde stack para asignación
    ldr x19, [x29, #128]
    ldr w20, [x29, #152]
    // Obtener puntero de fila para asignación
    add x21, x19, #8             // saltar header de matriz
    add x21, x21, w20, uxtw #3   // offset = fila * 8
    ldr x21, [x21]               // cargar puntero de fila
    ldr w22, [x29, #144]
    // Cargar puntero de matriz desde stack
    ldr x23, [x29, #96]
    str x23, [sp, #-16]!  // Preservar puntero matriz antes de evaluar índice fila
    ldr w24, [x29, #144]
    ldr x23, [sp], #16  // Restaurar puntero matriz desde stack
    // Acceso a fila: fila_ptr = matriz[fila]
    add x25, x23, #8             // saltar header de longitud
    add x25, x25, w24, uxtw #3   // offset = fila * 8
    ldr x25, [x25]               // cargar puntero de fila
    str x25, [sp, #-16]!  // Preservar puntero fila antes de evaluar índice columna
    ldr w26, [x29, #152]
    ldr x25, [sp], #16  // Restaurar puntero fila desde stack
    // Acceso a elemento: resultado = fila[columna]
    add x27, x25, #8             // saltar header de fila
    add x27, x27, w26, uxtw #2   // addr = fila_ptr + columna * 4
    ldr w28, [x27]               // cargar elemento desde addr
    // Asignación: fila[columna] = value
    add x23, x21, #8             // saltar header de fila
    add x23, x23, w22, uxtw #2   // addr = fila_ptr + columna * 4
    str w28, [x23]               // guardar valor
for_continue_8:  // Continue del for (actualización)
    // Actualización del for
    ldr w19, [x29, #152]
    str w19, [x29, #160]  // Preservar operando izq (prof=0)
    mov w20, #1
    ldr w19, [x29, #160]  // Restaurar operando izq (prof=0)
    add w21, w19, w20
    str w21, [x29, #152]      // Guardar int 'j' en stack
    b for_start_8  // Volver al inicio del for
for_end_8:  // Fin del for
for_continue_7:  // Continue del for (actualización)
    // Actualización del for
    ldr w19, [x29, #144]
    str w19, [x29, #160]  // Preservar operando izq (prof=0)
    mov w20, #1
    ldr w19, [x29, #160]  // Restaurar operando izq (prof=0)
    add w21, w19, w20
    str w21, [x29, #144]      // Guardar int 'i' en stack
    b for_start_7  // Volver al inicio del for
for_end_7:  // Fin del for
    ldr x19, [x29, #128]      // Cargar puntero del array 'transpuesta' desde stack
    mov x0, x19                 // Mover puntero a x0
    // Restaurar registros callee-saved (x19-x28)
    ldp x19, x20, [sp, #16]      // Restaurar x19, x20
    ldp x21, x22, [sp, #32]      // Restaurar x21, x22
    ldp x23, x24, [sp, #48]      // Restaurar x23, x24
    ldp x25, x26, [sp, #64]      // Restaurar x25, x26
    ldp x27, x28, [sp, #80]      // Restaurar x27, x28
    mov sp, x29                  // Restaurar SP a la base
    ldp x29, x30, [sp], #16      // Restaurar FP/LR desde base
    ret                          // Retornar

calcularDeterminante2x2:
    sub sp, sp, #368              // Reservar frame completo
    stp x29, x30, [sp]           // Guardar FP y LR
    mov x29, sp                  // Setup frame pointer (base)
    // Guardar registros callee-saved (x19-x28)
    stp x19, x20, [sp, #16]      // Guardar x19, x20
    stp x21, x22, [sp, #32]      // Guardar x21, x22
    stp x23, x24, [sp, #48]      // Guardar x23, x24
    stp x25, x26, [sp, #64]      // Guardar x25, x26
    stp x27, x28, [sp, #80]      // Guardar x27, x28

    // Parametros recibidos en registros
    // matriz: matriz ptr recibido en x0, preservando en stack
    str x0, [x29, #96]

    // Cargar puntero de matriz desde stack
    ldr x20, [x29, #96]
    str x20, [sp, #-16]!  // Preservar puntero matriz antes de evaluar índice fila
    mov w21, #0
    ldr x20, [sp], #16  // Restaurar puntero matriz desde stack
    // Acceso a fila: fila_ptr = matriz[fila]
    add x22, x20, #8             // saltar header de longitud
    add x22, x22, w21, uxtw #3   // offset = fila * 8
    ldr x22, [x22]               // cargar puntero de fila
    str x22, [sp, #-16]!  // Preservar puntero fila antes de evaluar índice columna
    mov w23, #0
    ldr x22, [sp], #16  // Restaurar puntero fila desde stack
    // Acceso a elemento: resultado = fila[columna]
    add x24, x22, #8             // saltar header de fila
    add x24, x24, w23, uxtw #2   // addr = fila_ptr + columna * 4
    ldr w25, [x24]               // cargar elemento desde addr
    str w25, [x29, #120]  // Preservar operando izq mult (prof=1)
    // Cargar puntero de matriz desde stack
    ldr x20, [x29, #96]
    str x20, [sp, #-16]!  // Preservar puntero matriz antes de evaluar índice fila
    mov w21, #1
    ldr x20, [sp], #16  // Restaurar puntero matriz desde stack
    // Acceso a fila: fila_ptr = matriz[fila]
    add x22, x20, #8             // saltar header de longitud
    add x22, x22, w21, uxtw #3   // offset = fila * 8
    ldr x22, [x22]               // cargar puntero de fila
    str x22, [sp, #-16]!  // Preservar puntero fila antes de evaluar índice columna
    mov w23, #1
    ldr x22, [sp], #16  // Restaurar puntero fila desde stack
    // Acceso a elemento: resultado = fila[columna]
    add x24, x22, #8             // saltar header de fila
    add x24, x24, w23, uxtw #2   // addr = fila_ptr + columna * 4
    ldr w26, [x24]               // cargar elemento desde addr
    ldr w25, [x29, #120]  // Restaurar operando izq mult (prof=1)
    mul w20, w25, w26
    str w20, [x29, #104]  // Preservar operando izq resta (prof=0)
    // Cargar puntero de matriz desde stack
    ldr x21, [x29, #96]
    str x21, [sp, #-16]!  // Preservar puntero matriz antes de evaluar índice fila
    mov w22, #0
    ldr x21, [sp], #16  // Restaurar puntero matriz desde stack
    // Acceso a fila: fila_ptr = matriz[fila]
    add x23, x21, #8             // saltar header de longitud
    add x23, x23, w22, uxtw #3   // offset = fila * 8
    ldr x23, [x23]               // cargar puntero de fila
    str x23, [sp, #-16]!  // Preservar puntero fila antes de evaluar índice columna
    mov w24, #1
    ldr x23, [sp], #16  // Restaurar puntero fila desde stack
    // Acceso a elemento: resultado = fila[columna]
    add x25, x23, #8             // saltar header de fila
    add x25, x25, w24, uxtw #2   // addr = fila_ptr + columna * 4
    ldr w26, [x25]               // cargar elemento desde addr
    str w26, [x29, #120]  // Preservar operando izq mult (prof=1)
    // Cargar puntero de matriz desde stack
    ldr x21, [x29, #96]
    str x21, [sp, #-16]!  // Preservar puntero matriz antes de evaluar índice fila
    mov w22, #1
    ldr x21, [sp], #16  // Restaurar puntero matriz desde stack
    // Acceso a fila: fila_ptr = matriz[fila]
    add x23, x21, #8             // saltar header de longitud
    add x23, x23, w22, uxtw #3   // offset = fila * 8
    ldr x23, [x23]               // cargar puntero de fila
    str x23, [sp, #-16]!  // Preservar puntero fila antes de evaluar índice columna
    mov w24, #0
    ldr x23, [sp], #16  // Restaurar puntero fila desde stack
    // Acceso a elemento: resultado = fila[columna]
    add x25, x23, #8             // saltar header de fila
    add x25, x25, w24, uxtw #2   // addr = fila_ptr + columna * 4
    ldr w27, [x25]               // cargar elemento desde addr
    ldr w26, [x29, #120]  // Restaurar operando izq mult (prof=1)
    mul w21, w26, w27
    ldr w20, [x29, #104]  // Restaurar operando izq resta (prof=0)
    sub w22, w20, w21
    mov w0, w22                 // Mover resultado a w0
    // Restaurar registros callee-saved (x19-x28)
    ldp x19, x20, [sp, #16]      // Restaurar x19, x20
    ldp x21, x22, [sp, #32]      // Restaurar x21, x22
    ldp x23, x24, [sp, #48]      // Restaurar x23, x24
    ldp x25, x26, [sp, #64]      // Restaurar x25, x26
    ldp x27, x28, [sp, #80]      // Restaurar x27, x28
    mov sp, x29                  // Restaurar SP a la base
    ldp x29, x30, [sp], #16      // Restaurar FP/LR desde base
    ret                          // Retornar

calcularDeterminante3x3:
    sub sp, sp, #368              // Reservar frame completo
    stp x29, x30, [sp]           // Guardar FP y LR
    mov x29, sp                  // Setup frame pointer (base)
    // Guardar registros callee-saved (x19-x28)
    stp x19, x20, [sp, #16]      // Guardar x19, x20
    stp x21, x22, [sp, #32]      // Guardar x21, x22
    stp x23, x24, [sp, #48]      // Guardar x23, x24
    stp x25, x26, [sp, #64]      // Guardar x25, x26
    stp x27, x28, [sp, #80]      // Guardar x27, x28

    // Parametros recibidos en registros
    // matriz: matriz ptr recibido en x0, preservando en stack
    str x0, [x29, #96]

    // Cargar puntero de matriz desde stack
    ldr x20, [x29, #96]
    str x20, [sp, #-16]!  // Preservar puntero matriz antes de evaluar índice fila
    mov w21, #0
    ldr x20, [sp], #16  // Restaurar puntero matriz desde stack
    // Acceso a fila: fila_ptr = matriz[fila]
    add x23, x20, #8             // saltar header de longitud
    add x23, x23, w21, uxtw #3   // offset = fila * 8
    ldr x23, [x23]               // cargar puntero de fila
    str x23, [sp, #-16]!  // Preservar puntero fila antes de evaluar índice columna
    mov w24, #0
    ldr x23, [sp], #16  // Restaurar puntero fila desde stack
    // Acceso a elemento: resultado = fila[columna]
    add x25, x23, #8             // saltar header de fila
    add x25, x25, w24, uxtw #2   // addr = fila_ptr + columna * 4
    ldr w26, [x25]               // cargar elemento desde addr
    str w26, [x29, #104]      // Guardar int 'a' en stack
    // Cargar puntero de matriz desde stack
    ldr x20, [x29, #96]
    str x20, [sp, #-16]!  // Preservar puntero matriz antes de evaluar índice fila
    mov w21, #0
    ldr x20, [sp], #16  // Restaurar puntero matriz desde stack
    // Acceso a fila: fila_ptr = matriz[fila]
    add x23, x20, #8             // saltar header de longitud
    add x23, x23, w21, uxtw #3   // offset = fila * 8
    ldr x23, [x23]               // cargar puntero de fila
    str x23, [sp, #-16]!  // Preservar puntero fila antes de evaluar índice columna
    mov w24, #1
    ldr x23, [sp], #16  // Restaurar puntero fila desde stack
    // Acceso a elemento: resultado = fila[columna]
    add x25, x23, #8             // saltar header de fila
    add x25, x25, w24, uxtw #2   // addr = fila_ptr + columna * 4
    ldr w26, [x25]               // cargar elemento desde addr
    str w26, [x29, #112]      // Guardar int 'b' en stack
    // Cargar puntero de matriz desde stack
    ldr x20, [x29, #96]
    str x20, [sp, #-16]!  // Preservar puntero matriz antes de evaluar índice fila
    mov w21, #0
    ldr x20, [sp], #16  // Restaurar puntero matriz desde stack
    // Acceso a fila: fila_ptr = matriz[fila]
    add x23, x20, #8             // saltar header de longitud
    add x23, x23, w21, uxtw #3   // offset = fila * 8
    ldr x23, [x23]               // cargar puntero de fila
    str x23, [sp, #-16]!  // Preservar puntero fila antes de evaluar índice columna
    mov w24, #2
    ldr x23, [sp], #16  // Restaurar puntero fila desde stack
    // Acceso a elemento: resultado = fila[columna]
    add x25, x23, #8             // saltar header de fila
    add x25, x25, w24, uxtw #2   // addr = fila_ptr + columna * 4
    ldr w26, [x25]               // cargar elemento desde addr
    str w26, [x29, #120]      // Guardar int 'c' en stack
    // Cargar puntero de matriz desde stack
    ldr x20, [x29, #96]
    str x20, [sp, #-16]!  // Preservar puntero matriz antes de evaluar índice fila
    mov w21, #1
    ldr x20, [sp], #16  // Restaurar puntero matriz desde stack
    // Acceso a fila: fila_ptr = matriz[fila]
    add x23, x20, #8             // saltar header de longitud
    add x23, x23, w21, uxtw #3   // offset = fila * 8
    ldr x23, [x23]               // cargar puntero de fila
    str x23, [sp, #-16]!  // Preservar puntero fila antes de evaluar índice columna
    mov w24, #1
    ldr x23, [sp], #16  // Restaurar puntero fila desde stack
    // Acceso a elemento: resultado = fila[columna]
    add x25, x23, #8             // saltar header de fila
    add x25, x25, w24, uxtw #2   // addr = fila_ptr + columna * 4
    ldr w26, [x25]               // cargar elemento desde addr
    str w26, [x29, #152]  // Preservar operando izq mult (prof=1)
    // Cargar puntero de matriz desde stack
    ldr x20, [x29, #96]
    str x20, [sp, #-16]!  // Preservar puntero matriz antes de evaluar índice fila
    mov w21, #2
    ldr x20, [sp], #16  // Restaurar puntero matriz desde stack
    // Acceso a fila: fila_ptr = matriz[fila]
    add x23, x20, #8             // saltar header de longitud
    add x23, x23, w21, uxtw #3   // offset = fila * 8
    ldr x23, [x23]               // cargar puntero de fila
    str x23, [sp, #-16]!  // Preservar puntero fila antes de evaluar índice columna
    mov w24, #2
    ldr x23, [sp], #16  // Restaurar puntero fila desde stack
    // Acceso a elemento: resultado = fila[columna]
    add x25, x23, #8             // saltar header de fila
    add x25, x25, w24, uxtw #2   // addr = fila_ptr + columna * 4
    ldr w27, [x25]               // cargar elemento desde addr
    ldr w26, [x29, #152]  // Restaurar operando izq mult (prof=1)
    mul w20, w26, w27
    str w20, [x29, #136]  // Preservar operando izq resta (prof=0)
    // Cargar puntero de matriz desde stack
    ldr x21, [x29, #96]
    str x21, [sp, #-16]!  // Preservar puntero matriz antes de evaluar índice fila
    mov w23, #1
    ldr x21, [sp], #16  // Restaurar puntero matriz desde stack
    // Acceso a fila: fila_ptr = matriz[fila]
    add x24, x21, #8             // saltar header de longitud
    add x24, x24, w23, uxtw #3   // offset = fila * 8
    ldr x24, [x24]               // cargar puntero de fila
    str x24, [sp, #-16]!  // Preservar puntero fila antes de evaluar índice columna
    mov w25, #2
    ldr x24, [sp], #16  // Restaurar puntero fila desde stack
    // Acceso a elemento: resultado = fila[columna]
    add x26, x24, #8             // saltar header de fila
    add x26, x26, w25, uxtw #2   // addr = fila_ptr + columna * 4
    ldr w27, [x26]               // cargar elemento desde addr
    str w27, [x29, #152]  // Preservar operando izq mult (prof=1)
    // Cargar puntero de matriz desde stack
    ldr x21, [x29, #96]
    str x21, [sp, #-16]!  // Preservar puntero matriz antes de evaluar índice fila
    mov w23, #2
    ldr x21, [sp], #16  // Restaurar puntero matriz desde stack
    // Acceso a fila: fila_ptr = matriz[fila]
    add x24, x21, #8             // saltar header de longitud
    add x24, x24, w23, uxtw #3   // offset = fila * 8
    ldr x24, [x24]               // cargar puntero de fila
    str x24, [sp, #-16]!  // Preservar puntero fila antes de evaluar índice columna
    mov w25, #1
    ldr x24, [sp], #16  // Restaurar puntero fila desde stack
    // Acceso a elemento: resultado = fila[columna]
    add x26, x24, #8             // saltar header de fila
    add x26, x26, w25, uxtw #2   // addr = fila_ptr + columna * 4
    ldr w28, [x26]               // cargar elemento desde addr
    ldr w27, [x29, #152]  // Restaurar operando izq mult (prof=1)
    mul w21, w27, w28
    ldr w20, [x29, #136]  // Restaurar operando izq resta (prof=0)
    sub w23, w20, w21
    str w23, [x29, #128]      // Guardar int 'menor1' en stack
    // Cargar puntero de matriz desde stack
    ldr x20, [x29, #96]
    str x20, [sp, #-16]!  // Preservar puntero matriz antes de evaluar índice fila
    mov w21, #1
    ldr x20, [sp], #16  // Restaurar puntero matriz desde stack
    // Acceso a fila: fila_ptr = matriz[fila]
    add x23, x20, #8             // saltar header de longitud
    add x23, x23, w21, uxtw #3   // offset = fila * 8
    ldr x23, [x23]               // cargar puntero de fila
    str x23, [sp, #-16]!  // Preservar puntero fila antes de evaluar índice columna
    mov w24, #0
    ldr x23, [sp], #16  // Restaurar puntero fila desde stack
    // Acceso a elemento: resultado = fila[columna]
    add x25, x23, #8             // saltar header de fila
    add x25, x25, w24, uxtw #2   // addr = fila_ptr + columna * 4
    ldr w26, [x25]               // cargar elemento desde addr
    str w26, [x29, #160]  // Preservar operando izq mult (prof=1)
    // Cargar puntero de matriz desde stack
    ldr x20, [x29, #96]
    str x20, [sp, #-16]!  // Preservar puntero matriz antes de evaluar índice fila
    mov w21, #2
    ldr x20, [sp], #16  // Restaurar puntero matriz desde stack
    // Acceso a fila: fila_ptr = matriz[fila]
    add x23, x20, #8             // saltar header de longitud
    add x23, x23, w21, uxtw #3   // offset = fila * 8
    ldr x23, [x23]               // cargar puntero de fila
    str x23, [sp, #-16]!  // Preservar puntero fila antes de evaluar índice columna
    mov w24, #2
    ldr x23, [sp], #16  // Restaurar puntero fila desde stack
    // Acceso a elemento: resultado = fila[columna]
    add x25, x23, #8             // saltar header de fila
    add x25, x25, w24, uxtw #2   // addr = fila_ptr + columna * 4
    ldr w27, [x25]               // cargar elemento desde addr
    ldr w26, [x29, #160]  // Restaurar operando izq mult (prof=1)
    mul w20, w26, w27
    str w20, [x29, #144]  // Preservar operando izq resta (prof=0)
    // Cargar puntero de matriz desde stack
    ldr x21, [x29, #96]
    str x21, [sp, #-16]!  // Preservar puntero matriz antes de evaluar índice fila
    mov w23, #1
    ldr x21, [sp], #16  // Restaurar puntero matriz desde stack
    // Acceso a fila: fila_ptr = matriz[fila]
    add x24, x21, #8             // saltar header de longitud
    add x24, x24, w23, uxtw #3   // offset = fila * 8
    ldr x24, [x24]               // cargar puntero de fila
    str x24, [sp, #-16]!  // Preservar puntero fila antes de evaluar índice columna
    mov w25, #2
    ldr x24, [sp], #16  // Restaurar puntero fila desde stack
    // Acceso a elemento: resultado = fila[columna]
    add x26, x24, #8             // saltar header de fila
    add x26, x26, w25, uxtw #2   // addr = fila_ptr + columna * 4
    ldr w27, [x26]               // cargar elemento desde addr
    str w27, [x29, #160]  // Preservar operando izq mult (prof=1)
    // Cargar puntero de matriz desde stack
    ldr x21, [x29, #96]
    str x21, [sp, #-16]!  // Preservar puntero matriz antes de evaluar índice fila
    mov w23, #2
    ldr x21, [sp], #16  // Restaurar puntero matriz desde stack
    // Acceso a fila: fila_ptr = matriz[fila]
    add x24, x21, #8             // saltar header de longitud
    add x24, x24, w23, uxtw #3   // offset = fila * 8
    ldr x24, [x24]               // cargar puntero de fila
    str x24, [sp, #-16]!  // Preservar puntero fila antes de evaluar índice columna
    mov w25, #0
    ldr x24, [sp], #16  // Restaurar puntero fila desde stack
    // Acceso a elemento: resultado = fila[columna]
    add x26, x24, #8             // saltar header de fila
    add x26, x26, w25, uxtw #2   // addr = fila_ptr + columna * 4
    ldr w28, [x26]               // cargar elemento desde addr
    ldr w27, [x29, #160]  // Restaurar operando izq mult (prof=1)
    mul w21, w27, w28
    ldr w20, [x29, #144]  // Restaurar operando izq resta (prof=0)
    sub w23, w20, w21
    str w23, [x29, #136]      // Guardar int 'menor2' en stack
    // Cargar puntero de matriz desde stack
    ldr x20, [x29, #96]
    str x20, [sp, #-16]!  // Preservar puntero matriz antes de evaluar índice fila
    mov w21, #1
    ldr x20, [sp], #16  // Restaurar puntero matriz desde stack
    // Acceso a fila: fila_ptr = matriz[fila]
    add x23, x20, #8             // saltar header de longitud
    add x23, x23, w21, uxtw #3   // offset = fila * 8
    ldr x23, [x23]               // cargar puntero de fila
    str x23, [sp, #-16]!  // Preservar puntero fila antes de evaluar índice columna
    mov w24, #0
    ldr x23, [sp], #16  // Restaurar puntero fila desde stack
    // Acceso a elemento: resultado = fila[columna]
    add x25, x23, #8             // saltar header de fila
    add x25, x25, w24, uxtw #2   // addr = fila_ptr + columna * 4
    ldr w26, [x25]               // cargar elemento desde addr
    str w26, [x29, #168]  // Preservar operando izq mult (prof=1)
    // Cargar puntero de matriz desde stack
    ldr x20, [x29, #96]
    str x20, [sp, #-16]!  // Preservar puntero matriz antes de evaluar índice fila
    mov w21, #2
    ldr x20, [sp], #16  // Restaurar puntero matriz desde stack
    // Acceso a fila: fila_ptr = matriz[fila]
    add x23, x20, #8             // saltar header de longitud
    add x23, x23, w21, uxtw #3   // offset = fila * 8
    ldr x23, [x23]               // cargar puntero de fila
    str x23, [sp, #-16]!  // Preservar puntero fila antes de evaluar índice columna
    mov w24, #1
    ldr x23, [sp], #16  // Restaurar puntero fila desde stack
    // Acceso a elemento: resultado = fila[columna]
    add x25, x23, #8             // saltar header de fila
    add x25, x25, w24, uxtw #2   // addr = fila_ptr + columna * 4
    ldr w27, [x25]               // cargar elemento desde addr
    ldr w26, [x29, #168]  // Restaurar operando izq mult (prof=1)
    mul w20, w26, w27
    str w20, [x29, #152]  // Preservar operando izq resta (prof=0)
    // Cargar puntero de matriz desde stack
    ldr x21, [x29, #96]
    str x21, [sp, #-16]!  // Preservar puntero matriz antes de evaluar índice fila
    mov w23, #1
    ldr x21, [sp], #16  // Restaurar puntero matriz desde stack
    // Acceso a fila: fila_ptr = matriz[fila]
    add x24, x21, #8             // saltar header de longitud
    add x24, x24, w23, uxtw #3   // offset = fila * 8
    ldr x24, [x24]               // cargar puntero de fila
    str x24, [sp, #-16]!  // Preservar puntero fila antes de evaluar índice columna
    mov w25, #1
    ldr x24, [sp], #16  // Restaurar puntero fila desde stack
    // Acceso a elemento: resultado = fila[columna]
    add x26, x24, #8             // saltar header de fila
    add x26, x26, w25, uxtw #2   // addr = fila_ptr + columna * 4
    ldr w27, [x26]               // cargar elemento desde addr
    str w27, [x29, #168]  // Preservar operando izq mult (prof=1)
    // Cargar puntero de matriz desde stack
    ldr x21, [x29, #96]
    str x21, [sp, #-16]!  // Preservar puntero matriz antes de evaluar índice fila
    mov w23, #2
    ldr x21, [sp], #16  // Restaurar puntero matriz desde stack
    // Acceso a fila: fila_ptr = matriz[fila]
    add x24, x21, #8             // saltar header de longitud
    add x24, x24, w23, uxtw #3   // offset = fila * 8
    ldr x24, [x24]               // cargar puntero de fila
    str x24, [sp, #-16]!  // Preservar puntero fila antes de evaluar índice columna
    mov w25, #0
    ldr x24, [sp], #16  // Restaurar puntero fila desde stack
    // Acceso a elemento: resultado = fila[columna]
    add x26, x24, #8             // saltar header de fila
    add x26, x26, w25, uxtw #2   // addr = fila_ptr + columna * 4
    ldr w28, [x26]               // cargar elemento desde addr
    ldr w27, [x29, #168]  // Restaurar operando izq mult (prof=1)
    mul w21, w27, w28
    ldr w20, [x29, #152]  // Restaurar operando izq resta (prof=0)
    sub w23, w20, w21
    str w23, [x29, #144]      // Guardar int 'menor3' en stack
    ldr w20, [x29, #104]
    str w20, [x29, #184]  // Preservar operando izq mult (prof=2)
    ldr w21, [x29, #128]
    ldr w20, [x29, #184]  // Restaurar operando izq mult (prof=2)
    mul w23, w20, w21
    str w23, [x29, #168]  // Preservar operando izq resta (prof=1)
    ldr w20, [x29, #112]
    str w20, [x29, #184]  // Preservar operando izq mult (prof=2)
    ldr w21, [x29, #136]
    ldr w20, [x29, #184]  // Restaurar operando izq mult (prof=2)
    mul w24, w20, w21
    ldr w23, [x29, #168]  // Restaurar operando izq resta (prof=1)
    sub w20, w23, w24
    str w20, [x29, #152]  // Preservar operando izq (prof=0)
    ldr w21, [x29, #120]
    str w21, [x29, #168]  // Preservar operando izq mult (prof=1)
    ldr w23, [x29, #144]
    ldr w21, [x29, #168]  // Restaurar operando izq mult (prof=1)
    mul w24, w21, w23
    ldr w20, [x29, #152]  // Restaurar operando izq (prof=0)
    add w21, w20, w24
    mov w0, w21                 // Mover resultado a w0
    // Restaurar registros callee-saved (x19-x28)
    ldp x19, x20, [sp, #16]      // Restaurar x19, x20
    ldp x21, x22, [sp, #32]      // Restaurar x21, x22
    ldp x23, x24, [sp, #48]      // Restaurar x23, x24
    ldp x25, x26, [sp, #64]      // Restaurar x25, x26
    ldp x27, x28, [sp, #80]      // Restaurar x27, x28
    mov sp, x29                  // Restaurar SP a la base
    ldp x29, x30, [sp], #16      // Restaurar FP/LR desde base
    ret                          // Retornar

main:
    // Frame muy grande: 5600 bytes
    sub sp, sp, #4095
    sub sp, sp, #1505
    stp x29, x30, [sp]            // Guardar FP/LR en tope del frame
    mov x29, sp                   // FP apunta al inicio del frame

    adrp x20, str_lit_4
    add x20, x20, :lo12:str_lit_4
    mov x0, x20
    bl print_string
    adrp x0, newline_5
    add x0, x0, :lo12:newline_5
    bl print_string
    adrp x20, str_lit_6
    add x20, x20, :lo12:str_lit_6
    mov x0, x20
    bl print_string
    adrp x0, newline_7
    add x0, x0, :lo12:newline_7
    bl print_string
    // Crear matriz con lista de elementos
    mov x0, #40               // 8 (header) + 4 filas * 8 bytes
    bl malloc
    mov x20, x0               // guardar puntero del array de filas
    mov x23, #4              // número de filas
    str x23, [x20]            // guardar longitud en header
    // Crear fila 0 (con header de 8 bytes)
    mov x0, #24               // 8 (header) + 4 elementos
    bl malloc
    mov x23, x0
    mov w24, #4              // número de elementos
    str w24, [x23]            // guardar longitud en header de fila (4 bytes)
    mov w24, #85
    str w24, [x23, #8]
    mov w24, #92
    str w24, [x23, #12]
    mov w24, #78
    str w24, [x23, #16]
    mov w24, #90
    str w24, [x23, #20]
    str x23, [x20, #8]       // matriz[0] = fila
    // Crear fila 1 (con header de 8 bytes)
    mov x0, #24               // 8 (header) + 4 elementos
    bl malloc
    mov x23, x0
    mov w24, #4              // número de elementos
    str w24, [x23]            // guardar longitud en header de fila (4 bytes)
    mov w24, #90
    str w24, [x23, #8]
    mov w24, #88
    str w24, [x23, #12]
    mov w24, #85
    str w24, [x23, #16]
    mov w24, #93
    str w24, [x23, #20]
    str x23, [x20, #16]       // matriz[1] = fila
    // Crear fila 2 (con header de 8 bytes)
    mov x0, #24               // 8 (header) + 4 elementos
    bl malloc
    mov x23, x0
    mov w24, #4              // número de elementos
    str w24, [x23]            // guardar longitud en header de fila (4 bytes)
    mov w24, #78
    str w24, [x23, #8]
    mov w24, #82
    str w24, [x23, #12]
    mov w24, #90
    str w24, [x23, #16]
    mov w24, #87
    str w24, [x23, #20]
    str x23, [x20, #24]       // matriz[2] = fila
    // Crear fila 3 (con header de 8 bytes)
    mov x0, #24               // 8 (header) + 4 elementos
    bl malloc
    mov x23, x0
    mov w24, #4              // número de elementos
    str w24, [x23]            // guardar longitud en header de fila (4 bytes)
    mov w24, #95
    str w24, [x23, #8]
    mov w24, #91
    str w24, [x23, #12]
    mov w24, #88
    str w24, [x23, #16]
    mov w24, #94
    str w24, [x23, #20]
    str x23, [x20, #32]       // matriz[3] = fila
    // Almacenar matriz en stack
    str x20, [x29, #152]
    mov w20, #4
    str w20, [x29, #176]  // Guardar dim[0] (filas)
    mov w20, #6
    str w20, [x29, #180]  // Guardar dim[1] (columnas)
    // Crear matriz 2D jerárquica
    mov x0, #2                // num_dimensiones = 2
    add x1, x29, #176          // puntero a dimensiones en stack
    mov x2, #4               // tipo_elemento
    mov x3, #8               // element_size
    bl create_multidim_array  // Llamar a función C helper
    mov x19, x0               // Guardar puntero resultante
    // Almacenar matriz en stack
    str x19, [x29, #184]
    // Crear matriz con lista de elementos
    mov x0, #32               // 8 (header) + 3 filas * 8 bytes
    bl malloc
    mov x20, x0               // guardar puntero del array de filas
    mov x23, #3              // número de filas
    str x23, [x20]            // guardar longitud en header
    // Crear fila 0 (con header de 8 bytes)
    mov x0, #20               // 8 (header) + 3 elementos
    bl malloc
    mov x23, x0
    mov w24, #3              // número de elementos
    str w24, [x23]            // guardar longitud en header de fila (4 bytes)
    mov w24, #3
    str w24, [x23, #8]
    mov w24, #2
    str w24, [x23, #12]
    mov w24, #1
    str w24, [x23, #16]
    str x23, [x20, #8]       // matriz[0] = fila
    // Crear fila 1 (con header de 8 bytes)
    mov x0, #20               // 8 (header) + 3 elementos
    bl malloc
    mov x23, x0
    mov w24, #3              // número de elementos
    str w24, [x23]            // guardar longitud en header de fila (4 bytes)
    mov w24, #1
    str w24, [x23, #8]
    mov w24, #4
    str w24, [x23, #12]
    mov w24, #2
    str w24, [x23, #16]
    str x23, [x20, #16]       // matriz[1] = fila
    // Crear fila 2 (con header de 8 bytes)
    mov x0, #20               // 8 (header) + 3 elementos
    bl malloc
    mov x23, x0
    mov w24, #3              // número de elementos
    str w24, [x23]            // guardar longitud en header de fila (4 bytes)
    mov w24, #2
    str w24, [x23, #8]
    mov w24, #1
    str w24, [x23, #12]
    mov w24, #3
    str w24, [x23, #16]
    str x23, [x20, #24]       // matriz[2] = fila
    // Almacenar matriz en stack
    str x20, [x29, #200]
    // Crear matriz con lista de elementos
    mov x0, #32               // 8 (header) + 3 filas * 8 bytes
    bl malloc
    mov x20, x0               // guardar puntero del array de filas
    mov x23, #3              // número de filas
    str x23, [x20]            // guardar longitud en header
    // Crear fila 0 (con header de 8 bytes)
    mov x0, #20               // 8 (header) + 3 elementos
    bl malloc
    mov x23, x0
    mov w24, #3              // número de elementos
    str w24, [x23]            // guardar longitud en header de fila (4 bytes)
    mov w24, #2
    str w24, [x23, #8]
    mov w24, #1
    str w24, [x23, #12]
    mov w24, #3
    str w24, [x23, #16]
    str x23, [x20, #8]       // matriz[0] = fila
    // Crear fila 1 (con header de 8 bytes)
    mov x0, #20               // 8 (header) + 3 elementos
    bl malloc
    mov x23, x0
    mov w24, #3              // número de elementos
    str w24, [x23]            // guardar longitud en header de fila (4 bytes)
    mov w24, #3
    str w24, [x23, #8]
    mov w24, #2
    str w24, [x23, #12]
    mov w24, #1
    str w24, [x23, #16]
    str x23, [x20, #16]       // matriz[1] = fila
    // Crear fila 2 (con header de 8 bytes)
    mov x0, #20               // 8 (header) + 3 elementos
    bl malloc
    mov x23, x0
    mov w24, #3              // número de elementos
    str w24, [x23]            // guardar longitud en header de fila (4 bytes)
    mov w24, #1
    str w24, [x23, #8]
    mov w24, #3
    str w24, [x23, #12]
    mov w24, #2
    str w24, [x23, #16]
    str x23, [x20, #24]       // matriz[2] = fila
    // Almacenar matriz en stack
    str x20, [x29, #224]
    adrp x20, str_lit_8
    add x20, x20, :lo12:str_lit_8
    mov x0, x20
    bl print_string
    adrp x0, newline_9
    add x0, x0, :lo12:newline_9
    bl print_string
    adrp x20, str_lit_10
    add x20, x20, :lo12:str_lit_10
    mov x0, x20
    str x0, [sp, #-16]!
    ldr x20, [x29, #152]      // Cargar puntero del array 'calificacionesPorMateria' desde stack
    // Array.length: cargar longitud del array
    ldr w19, [x20, #0]        // longitud = array[0] (4 bytes)
    // String.valueOf() - Reservar buffer para resultado
    mov x0, #64                      // Tamaño del buffer
    bl malloc                         // Llamar a malloc
    str x0, [x29, #24]               // Guardar puntero al buffer en stack temporal (#24)
    // String.valueOf(int)
    ldr x0, [x29, #24]             // Cargar buffer desde stack
    mov x1, #64                   // tamaño del buffer
    adrp x2, .Lfmt_int            // Formato %d
    add x2, x2, :lo12:.Lfmt_int
    mov w3, w19                   // Valor int a convertir
    bl snprintf
    ldr x21, [x29, #24]             // Cargar buffer desde stack
    mov x19, x21                      // Mover resultado a x19
    mov x0, x19
    mov x1, x0
    ldr x0, [sp], #16
    // Concatenar string + string usando runtime C
    bl concat_string_string      // Llama a función C optimizada
    str x0, [sp, #-16]!
    adrp x19, str_lit_11
    add x19, x19, :lo12:str_lit_11
    mov x0, x19
    mov x1, x0
    ldr x0, [sp], #16
    // Concatenar string + string usando runtime C
    bl concat_string_string      // Llama a función C optimizada
    str x0, [sp, #-16]!
    // Cargar puntero del array desde stack
    ldr x19, [x29, #152]      // cargar puntero del array desde stack
    str x19, [sp, #-16]!  // Preservar puntero vector antes de evaluar índice
    mov w19, #0
    ldr x20, [sp], #16  // Restaurar puntero del vector desde stack
    // Acceso a matriz: matriz[index] retorna puntero
    add x22, x20, #8             // saltar header (4) + padding (4)
    add x22, x22, w19, uxtw #3   // calcular dirección: matriz + index * 8
    ldr x21, [x22]               // cargar puntero del sub-array
    // Array.length: cargar longitud del array
    ldr w19, [x21, #0]        // longitud = array[0] (4 bytes)
    // String.valueOf() - Reservar buffer para resultado
    mov x0, #64                      // Tamaño del buffer
    bl malloc                         // Llamar a malloc
    str x0, [x29, #24]               // Guardar puntero al buffer en stack temporal (#24)
    // String.valueOf(int)
    ldr x0, [x29, #24]             // Cargar buffer desde stack
    mov x1, #64                   // tamaño del buffer
    adrp x2, .Lfmt_int            // Formato %d
    add x2, x2, :lo12:.Lfmt_int
    mov w3, w19                   // Valor int a convertir
    bl snprintf
    ldr x21, [x29, #24]             // Cargar buffer desde stack
    mov x19, x21                      // Mover resultado a x19
    mov x0, x19
    mov x1, x0
    ldr x0, [sp], #16
    // Concatenar string + string usando runtime C
    bl concat_string_string      // Llama a función C optimizada
    bl print_string
    adrp x0, newline_12
    add x0, x0, :lo12:newline_12
    bl print_string
    adrp x19, str_lit_13
    add x19, x19, :lo12:str_lit_13
    mov x0, x19
    str x0, [sp, #-16]!
    ldr x20, [x29, #184]      // Cargar puntero del array 'promediosPorSemestre' desde stack
    // Array.length: cargar longitud del array
    ldr w19, [x20, #0]        // longitud = array[0] (4 bytes)
    // String.valueOf() - Reservar buffer para resultado
    mov x0, #64                      // Tamaño del buffer
    bl malloc                         // Llamar a malloc
    str x0, [x29, #24]               // Guardar puntero al buffer en stack temporal (#24)
    // String.valueOf(int)
    ldr x0, [x29, #24]             // Cargar buffer desde stack
    mov x1, #64                   // tamaño del buffer
    adrp x2, .Lfmt_int            // Formato %d
    add x2, x2, :lo12:.Lfmt_int
    mov w3, w19                   // Valor int a convertir
    bl snprintf
    ldr x21, [x29, #24]             // Cargar buffer desde stack
    mov x19, x21                      // Mover resultado a x19
    mov x0, x19
    mov x1, x0
    ldr x0, [sp], #16
    // Concatenar string + string usando runtime C
    bl concat_string_string      // Llama a función C optimizada
    str x0, [sp, #-16]!
    adrp x19, str_lit_14
    add x19, x19, :lo12:str_lit_14
    mov x0, x19
    mov x1, x0
    ldr x0, [sp], #16
    // Concatenar string + string usando runtime C
    bl concat_string_string      // Llama a función C optimizada
    str x0, [sp, #-16]!
    // Cargar puntero del array desde stack
    ldr x19, [x29, #184]      // cargar puntero del array desde stack
    str x19, [sp, #-16]!  // Preservar puntero vector antes de evaluar índice
    mov w19, #0
    ldr x20, [sp], #16  // Restaurar puntero del vector desde stack
    // Acceso a matriz: matriz[index] retorna puntero
    add x22, x20, #8             // saltar header (4) + padding (4)
    add x22, x22, w19, uxtw #3   // calcular dirección: matriz + index * 8
    ldr x21, [x22]               // cargar puntero del sub-array
    // Array.length: cargar longitud del array
    ldr w19, [x21, #0]        // longitud = array[0] (4 bytes)
    // String.valueOf() - Reservar buffer para resultado
    mov x0, #64                      // Tamaño del buffer
    bl malloc                         // Llamar a malloc
    str x0, [x29, #24]               // Guardar puntero al buffer en stack temporal (#24)
    // String.valueOf(int)
    ldr x0, [x29, #24]             // Cargar buffer desde stack
    mov x1, #64                   // tamaño del buffer
    adrp x2, .Lfmt_int            // Formato %d
    add x2, x2, :lo12:.Lfmt_int
    mov w3, w19                   // Valor int a convertir
    bl snprintf
    ldr x21, [x29, #24]             // Cargar buffer desde stack
    mov x19, x21                      // Mover resultado a x19
    mov x0, x19
    mov x1, x0
    ldr x0, [sp], #16
    // Concatenar string + string usando runtime C
    bl concat_string_string      // Llama a función C optimizada
    bl print_string
    adrp x0, newline_15
    add x0, x0, :lo12:newline_15
    bl print_string
    adrp x19, str_lit_16
    add x19, x19, :lo12:str_lit_16
    mov x0, x19
    str x0, [sp, #-16]!
    ldr x20, [x29, #200]      // Cargar puntero del array 'matrizA' desde stack
    // Array.length: cargar longitud del array
    ldr w19, [x20, #0]        // longitud = array[0] (4 bytes)
    // String.valueOf() - Reservar buffer para resultado
    mov x0, #64                      // Tamaño del buffer
    bl malloc                         // Llamar a malloc
    str x0, [x29, #24]               // Guardar puntero al buffer en stack temporal (#24)
    // String.valueOf(int)
    ldr x0, [x29, #24]             // Cargar buffer desde stack
    mov x1, #64                   // tamaño del buffer
    adrp x2, .Lfmt_int            // Formato %d
    add x2, x2, :lo12:.Lfmt_int
    mov w3, w19                   // Valor int a convertir
    bl snprintf
    ldr x21, [x29, #24]             // Cargar buffer desde stack
    mov x19, x21                      // Mover resultado a x19
    mov x0, x19
    mov x1, x0
    ldr x0, [sp], #16
    // Concatenar string + string usando runtime C
    bl concat_string_string      // Llama a función C optimizada
    str x0, [sp, #-16]!
    adrp x19, str_lit_17
    add x19, x19, :lo12:str_lit_17
    mov x0, x19
    mov x1, x0
    ldr x0, [sp], #16
    // Concatenar string + string usando runtime C
    bl concat_string_string      // Llama a función C optimizada
    str x0, [sp, #-16]!
    // Cargar puntero del array desde stack
    ldr x19, [x29, #200]      // cargar puntero del array desde stack
    str x19, [sp, #-16]!  // Preservar puntero vector antes de evaluar índice
    mov w19, #0
    ldr x20, [sp], #16  // Restaurar puntero del vector desde stack
    // Acceso a matriz: matriz[index] retorna puntero
    add x22, x20, #8             // saltar header (4) + padding (4)
    add x22, x22, w19, uxtw #3   // calcular dirección: matriz + index * 8
    ldr x21, [x22]               // cargar puntero del sub-array
    // Array.length: cargar longitud del array
    ldr w19, [x21, #0]        // longitud = array[0] (4 bytes)
    // String.valueOf() - Reservar buffer para resultado
    mov x0, #64                      // Tamaño del buffer
    bl malloc                         // Llamar a malloc
    str x0, [x29, #24]               // Guardar puntero al buffer en stack temporal (#24)
    // String.valueOf(int)
    ldr x0, [x29, #24]             // Cargar buffer desde stack
    mov x1, #64                   // tamaño del buffer
    adrp x2, .Lfmt_int            // Formato %d
    add x2, x2, :lo12:.Lfmt_int
    mov w3, w19                   // Valor int a convertir
    bl snprintf
    ldr x21, [x29, #24]             // Cargar buffer desde stack
    mov x19, x21                      // Mover resultado a x19
    mov x0, x19
    mov x1, x0
    ldr x0, [sp], #16
    // Concatenar string + string usando runtime C
    bl concat_string_string      // Llama a función C optimizada
    bl print_string
    adrp x0, newline_18
    add x0, x0, :lo12:newline_18
    bl print_string
    adrp x19, str_lit_19
    add x19, x19, :lo12:str_lit_19
    mov x0, x19
    str x0, [sp, #-16]!
    ldr x20, [x29, #224]      // Cargar puntero del array 'matrizB' desde stack
    // Array.length: cargar longitud del array
    ldr w19, [x20, #0]        // longitud = array[0] (4 bytes)
    // String.valueOf() - Reservar buffer para resultado
    mov x0, #64                      // Tamaño del buffer
    bl malloc                         // Llamar a malloc
    str x0, [x29, #24]               // Guardar puntero al buffer en stack temporal (#24)
    // String.valueOf(int)
    ldr x0, [x29, #24]             // Cargar buffer desde stack
    mov x1, #64                   // tamaño del buffer
    adrp x2, .Lfmt_int            // Formato %d
    add x2, x2, :lo12:.Lfmt_int
    mov w3, w19                   // Valor int a convertir
    bl snprintf
    ldr x21, [x29, #24]             // Cargar buffer desde stack
    mov x19, x21                      // Mover resultado a x19
    mov x0, x19
    mov x1, x0
    ldr x0, [sp], #16
    // Concatenar string + string usando runtime C
    bl concat_string_string      // Llama a función C optimizada
    str x0, [sp, #-16]!
    adrp x19, str_lit_20
    add x19, x19, :lo12:str_lit_20
    mov x0, x19
    mov x1, x0
    ldr x0, [sp], #16
    // Concatenar string + string usando runtime C
    bl concat_string_string      // Llama a función C optimizada
    str x0, [sp, #-16]!
    // Cargar puntero del array desde stack
    ldr x19, [x29, #224]      // cargar puntero del array desde stack
    str x19, [sp, #-16]!  // Preservar puntero vector antes de evaluar índice
    mov w19, #0
    ldr x20, [sp], #16  // Restaurar puntero del vector desde stack
    // Acceso a matriz: matriz[index] retorna puntero
    add x22, x20, #8             // saltar header (4) + padding (4)
    add x22, x22, w19, uxtw #3   // calcular dirección: matriz + index * 8
    ldr x21, [x22]               // cargar puntero del sub-array
    // Array.length: cargar longitud del array
    ldr w19, [x21, #0]        // longitud = array[0] (4 bytes)
    // String.valueOf() - Reservar buffer para resultado
    mov x0, #64                      // Tamaño del buffer
    bl malloc                         // Llamar a malloc
    str x0, [x29, #24]               // Guardar puntero al buffer en stack temporal (#24)
    // String.valueOf(int)
    ldr x0, [x29, #24]             // Cargar buffer desde stack
    mov x1, #64                   // tamaño del buffer
    adrp x2, .Lfmt_int            // Formato %d
    add x2, x2, :lo12:.Lfmt_int
    mov w3, w19                   // Valor int a convertir
    bl snprintf
    ldr x21, [x29, #24]             // Cargar buffer desde stack
    mov x19, x21                      // Mover resultado a x19
    mov x0, x19
    mov x1, x0
    ldr x0, [sp], #16
    // Concatenar string + string usando runtime C
    bl concat_string_string      // Llama a función C optimizada
    bl print_string
    adrp x0, newline_21
    add x0, x0, :lo12:newline_21
    bl print_string
    adrp x19, str_lit_22
    add x19, x19, :lo12:str_lit_22
    mov x0, x19
    bl print_string
    adrp x0, newline_23
    add x0, x0, :lo12:newline_23
    bl print_string
    mov w19, #4
    str w19, [x29, #248]  // Guardar dim[0]
    mov w19, #4
    str w19, [x29, #252]  // Guardar dim[1]
    mov w19, #3
    str w19, [x29, #256]  // Guardar dim[2]
    // Crear array multidimensional jerárquico
    mov x0, #3              // num_dimensiones
    add x1, x29, #248          // puntero a dimensiones en stack
    mov x2, #2               // tipo_elemento
    mov x3, #4               // element_size
    bl create_multidim_array  // Llamar a función C helper
    mov x19, x0               // Guardar puntero resultante
    // Almacenar array multidimensional en stack
    str x19, [x29, #264]
    mov w19, #2
    str w19, [x29, #288]  // Guardar dim[0]
    mov w19, #3
    str w19, [x29, #292]  // Guardar dim[1]
    mov w19, #3
    str w19, [x29, #296]  // Guardar dim[2]
    // Crear array multidimensional jerárquico
    mov x0, #3              // num_dimensiones
    add x1, x29, #288          // puntero a dimensiones en stack
    mov x2, #4               // tipo_elemento
    mov x3, #8               // element_size
    bl create_multidim_array  // Llamar a función C helper
    mov x19, x0               // Guardar puntero resultante
    // Almacenar array multidimensional en stack
    str x19, [x29, #304]
    // temperaturasPorDia[0][0][0] = 20.500000
    ldr x19, [x29, #304]  // Cargar puntero array
    add x20, x19, #8              // Saltar header nivel 0
    mov w21, #0                  // índice i0
    add x20, x20, w21, uxtw #3    // offset = i0 * 8
    ldr x20, [x20]                // Cargar puntero nivel 1
    add x21, x20, #8              // Saltar header nivel 1
    mov w22, #0                  // índice i1
    add x21, x21, w22, uxtw #3    // offset = i1 * 8
    ldr x21, [x21]                // Cargar puntero nivel 2
    ldr d0, =0x4034800000000000          // Valor 20.500000
    add x22, x21, #8              // Saltar header nivel 2
    mov w23, #0                  // índice i2
    add x22, x22, w23, uxtw #3   // offset = i2 * 8
    str d0, [x22]                 // Guardar valor
    // temperaturasPorDia[0][0][1] = 22.100000
    ldr x19, [x29, #304]  // Cargar puntero array
    add x20, x19, #8              // Saltar header nivel 0
    mov w21, #0                  // índice i0
    add x20, x20, w21, uxtw #3    // offset = i0 * 8
    ldr x20, [x20]                // Cargar puntero nivel 1
    add x21, x20, #8              // Saltar header nivel 1
    mov w22, #0                  // índice i1
    add x21, x21, w22, uxtw #3    // offset = i1 * 8
    ldr x21, [x21]                // Cargar puntero nivel 2
    ldr d0, =0x403619999999999a          // Valor 22.100000
    add x22, x21, #8              // Saltar header nivel 2
    mov w23, #1                  // índice i2
    add x22, x22, w23, uxtw #3   // offset = i2 * 8
    str d0, [x22]                 // Guardar valor
    // temperaturasPorDia[0][0][2] = 25.300000
    ldr x19, [x29, #304]  // Cargar puntero array
    add x20, x19, #8              // Saltar header nivel 0
    mov w21, #0                  // índice i0
    add x20, x20, w21, uxtw #3    // offset = i0 * 8
    ldr x20, [x20]                // Cargar puntero nivel 1
    add x21, x20, #8              // Saltar header nivel 1
    mov w22, #0                  // índice i1
    add x21, x21, w22, uxtw #3    // offset = i1 * 8
    ldr x21, [x21]                // Cargar puntero nivel 2
    ldr d0, =0x40394ccccccccccd          // Valor 25.300000
    add x22, x21, #8              // Saltar header nivel 2
    mov w23, #2                  // índice i2
    add x22, x22, w23, uxtw #3   // offset = i2 * 8
    str d0, [x22]                 // Guardar valor
    // temperaturasPorDia[0][1][0] = 19.800000
    ldr x19, [x29, #304]  // Cargar puntero array
    add x20, x19, #8              // Saltar header nivel 0
    mov w21, #0                  // índice i0
    add x20, x20, w21, uxtw #3    // offset = i0 * 8
    ldr x20, [x20]                // Cargar puntero nivel 1
    add x21, x20, #8              // Saltar header nivel 1
    mov w22, #1                  // índice i1
    add x21, x21, w22, uxtw #3    // offset = i1 * 8
    ldr x21, [x21]                // Cargar puntero nivel 2
    ldr d0, =0x4033cccccccccccd          // Valor 19.800000
    add x22, x21, #8              // Saltar header nivel 2
    mov w23, #0                  // índice i2
    add x22, x22, w23, uxtw #3   // offset = i2 * 8
    str d0, [x22]                 // Guardar valor
    // temperaturasPorDia[0][1][1] = 21.500000
    ldr x19, [x29, #304]  // Cargar puntero array
    add x20, x19, #8              // Saltar header nivel 0
    mov w21, #0                  // índice i0
    add x20, x20, w21, uxtw #3    // offset = i0 * 8
    ldr x20, [x20]                // Cargar puntero nivel 1
    add x21, x20, #8              // Saltar header nivel 1
    mov w22, #1                  // índice i1
    add x21, x21, w22, uxtw #3    // offset = i1 * 8
    ldr x21, [x21]                // Cargar puntero nivel 2
    ldr d0, =0x4035800000000000          // Valor 21.500000
    add x22, x21, #8              // Saltar header nivel 2
    mov w23, #1                  // índice i2
    add x22, x22, w23, uxtw #3   // offset = i2 * 8
    str d0, [x22]                 // Guardar valor
    // temperaturasPorDia[0][1][2] = 24.700000
    ldr x19, [x29, #304]  // Cargar puntero array
    add x20, x19, #8              // Saltar header nivel 0
    mov w21, #0                  // índice i0
    add x20, x20, w21, uxtw #3    // offset = i0 * 8
    ldr x20, [x20]                // Cargar puntero nivel 1
    add x21, x20, #8              // Saltar header nivel 1
    mov w22, #1                  // índice i1
    add x21, x21, w22, uxtw #3    // offset = i1 * 8
    ldr x21, [x21]                // Cargar puntero nivel 2
    ldr d0, =0x4038b33333333333          // Valor 24.700000
    add x22, x21, #8              // Saltar header nivel 2
    mov w23, #2                  // índice i2
    add x22, x22, w23, uxtw #3   // offset = i2 * 8
    str d0, [x22]                 // Guardar valor
    // temperaturasPorDia[0][2][0] = 21.200000
    ldr x19, [x29, #304]  // Cargar puntero array
    add x20, x19, #8              // Saltar header nivel 0
    mov w21, #0                  // índice i0
    add x20, x20, w21, uxtw #3    // offset = i0 * 8
    ldr x20, [x20]                // Cargar puntero nivel 1
    add x21, x20, #8              // Saltar header nivel 1
    mov w22, #2                  // índice i1
    add x21, x21, w22, uxtw #3    // offset = i1 * 8
    ldr x21, [x21]                // Cargar puntero nivel 2
    ldr d0, =0x4035333333333333          // Valor 21.200000
    add x22, x21, #8              // Saltar header nivel 2
    mov w23, #0                  // índice i2
    add x22, x22, w23, uxtw #3   // offset = i2 * 8
    str d0, [x22]                 // Guardar valor
    // temperaturasPorDia[0][2][1] = 23.000000
    ldr x19, [x29, #304]  // Cargar puntero array
    add x20, x19, #8              // Saltar header nivel 0
    mov w21, #0                  // índice i0
    add x20, x20, w21, uxtw #3    // offset = i0 * 8
    ldr x20, [x20]                // Cargar puntero nivel 1
    add x21, x20, #8              // Saltar header nivel 1
    mov w22, #2                  // índice i1
    add x21, x21, w22, uxtw #3    // offset = i1 * 8
    ldr x21, [x21]                // Cargar puntero nivel 2
    ldr d0, =0x4037000000000000          // Valor 23.000000
    add x22, x21, #8              // Saltar header nivel 2
    mov w23, #1                  // índice i2
    add x22, x22, w23, uxtw #3   // offset = i2 * 8
    str d0, [x22]                 // Guardar valor
    // temperaturasPorDia[0][2][2] = 26.100000
    ldr x19, [x29, #304]  // Cargar puntero array
    add x20, x19, #8              // Saltar header nivel 0
    mov w21, #0                  // índice i0
    add x20, x20, w21, uxtw #3    // offset = i0 * 8
    ldr x20, [x20]                // Cargar puntero nivel 1
    add x21, x20, #8              // Saltar header nivel 1
    mov w22, #2                  // índice i1
    add x21, x21, w22, uxtw #3    // offset = i1 * 8
    ldr x21, [x21]                // Cargar puntero nivel 2
    ldr d0, =0x403a19999999999a          // Valor 26.100000
    add x22, x21, #8              // Saltar header nivel 2
    mov w23, #2                  // índice i2
    add x22, x22, w23, uxtw #3   // offset = i2 * 8
    str d0, [x22]                 // Guardar valor
    // temperaturasPorDia[1][0][0] = 18.500000
    ldr x19, [x29, #304]  // Cargar puntero array
    add x20, x19, #8              // Saltar header nivel 0
    mov w21, #1                  // índice i0
    add x20, x20, w21, uxtw #3    // offset = i0 * 8
    ldr x20, [x20]                // Cargar puntero nivel 1
    add x21, x20, #8              // Saltar header nivel 1
    mov w22, #0                  // índice i1
    add x21, x21, w22, uxtw #3    // offset = i1 * 8
    ldr x21, [x21]                // Cargar puntero nivel 2
    ldr d0, =0x4032800000000000          // Valor 18.500000
    add x22, x21, #8              // Saltar header nivel 2
    mov w23, #0                  // índice i2
    add x22, x22, w23, uxtw #3   // offset = i2 * 8
    str d0, [x22]                 // Guardar valor
    // temperaturasPorDia[1][0][1] = 20.100000
    ldr x19, [x29, #304]  // Cargar puntero array
    add x20, x19, #8              // Saltar header nivel 0
    mov w21, #1                  // índice i0
    add x20, x20, w21, uxtw #3    // offset = i0 * 8
    ldr x20, [x20]                // Cargar puntero nivel 1
    add x21, x20, #8              // Saltar header nivel 1
    mov w22, #0                  // índice i1
    add x21, x21, w22, uxtw #3    // offset = i1 * 8
    ldr x21, [x21]                // Cargar puntero nivel 2
    ldr d0, =0x403419999999999a          // Valor 20.100000
    add x22, x21, #8              // Saltar header nivel 2
    mov w23, #1                  // índice i2
    add x22, x22, w23, uxtw #3   // offset = i2 * 8
    str d0, [x22]                 // Guardar valor
    // temperaturasPorDia[1][0][2] = 23.300000
    ldr x19, [x29, #304]  // Cargar puntero array
    add x20, x19, #8              // Saltar header nivel 0
    mov w21, #1                  // índice i0
    add x20, x20, w21, uxtw #3    // offset = i0 * 8
    ldr x20, [x20]                // Cargar puntero nivel 1
    add x21, x20, #8              // Saltar header nivel 1
    mov w22, #0                  // índice i1
    add x21, x21, w22, uxtw #3    // offset = i1 * 8
    ldr x21, [x21]                // Cargar puntero nivel 2
    ldr d0, =0x40374ccccccccccd          // Valor 23.300000
    add x22, x21, #8              // Saltar header nivel 2
    mov w23, #2                  // índice i2
    add x22, x22, w23, uxtw #3   // offset = i2 * 8
    str d0, [x22]                 // Guardar valor
    // temperaturasPorDia[1][1][0] = 17.800000
    ldr x19, [x29, #304]  // Cargar puntero array
    add x20, x19, #8              // Saltar header nivel 0
    mov w21, #1                  // índice i0
    add x20, x20, w21, uxtw #3    // offset = i0 * 8
    ldr x20, [x20]                // Cargar puntero nivel 1
    add x21, x20, #8              // Saltar header nivel 1
    mov w22, #1                  // índice i1
    add x21, x21, w22, uxtw #3    // offset = i1 * 8
    ldr x21, [x21]                // Cargar puntero nivel 2
    ldr d0, =0x4031cccccccccccd          // Valor 17.800000
    add x22, x21, #8              // Saltar header nivel 2
    mov w23, #0                  // índice i2
    add x22, x22, w23, uxtw #3   // offset = i2 * 8
    str d0, [x22]                 // Guardar valor
    // temperaturasPorDia[1][1][1] = 19.500000
    ldr x19, [x29, #304]  // Cargar puntero array
    add x20, x19, #8              // Saltar header nivel 0
    mov w21, #1                  // índice i0
    add x20, x20, w21, uxtw #3    // offset = i0 * 8
    ldr x20, [x20]                // Cargar puntero nivel 1
    add x21, x20, #8              // Saltar header nivel 1
    mov w22, #1                  // índice i1
    add x21, x21, w22, uxtw #3    // offset = i1 * 8
    ldr x21, [x21]                // Cargar puntero nivel 2
    ldr d0, =0x4033800000000000          // Valor 19.500000
    add x22, x21, #8              // Saltar header nivel 2
    mov w23, #1                  // índice i2
    add x22, x22, w23, uxtw #3   // offset = i2 * 8
    str d0, [x22]                 // Guardar valor
    // temperaturasPorDia[1][1][2] = 22.700000
    ldr x19, [x29, #304]  // Cargar puntero array
    add x20, x19, #8              // Saltar header nivel 0
    mov w21, #1                  // índice i0
    add x20, x20, w21, uxtw #3    // offset = i0 * 8
    ldr x20, [x20]                // Cargar puntero nivel 1
    add x21, x20, #8              // Saltar header nivel 1
    mov w22, #1                  // índice i1
    add x21, x21, w22, uxtw #3    // offset = i1 * 8
    ldr x21, [x21]                // Cargar puntero nivel 2
    ldr d0, =0x4036b33333333333          // Valor 22.700000
    add x22, x21, #8              // Saltar header nivel 2
    mov w23, #2                  // índice i2
    add x22, x22, w23, uxtw #3   // offset = i2 * 8
    str d0, [x22]                 // Guardar valor
    // temperaturasPorDia[1][2][0] = 19.200000
    ldr x19, [x29, #304]  // Cargar puntero array
    add x20, x19, #8              // Saltar header nivel 0
    mov w21, #1                  // índice i0
    add x20, x20, w21, uxtw #3    // offset = i0 * 8
    ldr x20, [x20]                // Cargar puntero nivel 1
    add x21, x20, #8              // Saltar header nivel 1
    mov w22, #2                  // índice i1
    add x21, x21, w22, uxtw #3    // offset = i1 * 8
    ldr x21, [x21]                // Cargar puntero nivel 2
    ldr d0, =0x4033333333333333          // Valor 19.200000
    add x22, x21, #8              // Saltar header nivel 2
    mov w23, #0                  // índice i2
    add x22, x22, w23, uxtw #3   // offset = i2 * 8
    str d0, [x22]                 // Guardar valor
    // temperaturasPorDia[1][2][1] = 21.000000
    ldr x19, [x29, #304]  // Cargar puntero array
    add x20, x19, #8              // Saltar header nivel 0
    mov w21, #1                  // índice i0
    add x20, x20, w21, uxtw #3    // offset = i0 * 8
    ldr x20, [x20]                // Cargar puntero nivel 1
    add x21, x20, #8              // Saltar header nivel 1
    mov w22, #2                  // índice i1
    add x21, x21, w22, uxtw #3    // offset = i1 * 8
    ldr x21, [x21]                // Cargar puntero nivel 2
    ldr d0, =0x4035000000000000          // Valor 21.000000
    add x22, x21, #8              // Saltar header nivel 2
    mov w23, #1                  // índice i2
    add x22, x22, w23, uxtw #3   // offset = i2 * 8
    str d0, [x22]                 // Guardar valor
    // temperaturasPorDia[1][2][2] = 24.100000
    ldr x19, [x29, #304]  // Cargar puntero array
    add x20, x19, #8              // Saltar header nivel 0
    mov w21, #1                  // índice i0
    add x20, x20, w21, uxtw #3    // offset = i0 * 8
    ldr x20, [x20]                // Cargar puntero nivel 1
    add x21, x20, #8              // Saltar header nivel 1
    mov w22, #2                  // índice i1
    add x21, x21, w22, uxtw #3    // offset = i1 * 8
    ldr x21, [x21]                // Cargar puntero nivel 2
    ldr d0, =0x403819999999999a          // Valor 24.100000
    add x22, x21, #8              // Saltar header nivel 2
    mov w23, #2                  // índice i2
    add x22, x22, w23, uxtw #3   // offset = i2 * 8
    str d0, [x22]                 // Guardar valor
    adrp x20, str_lit_24
    add x20, x20, :lo12:str_lit_24
    mov x0, x20
    bl print_string
    adrp x0, newline_25
    add x0, x0, :lo12:newline_25
    bl print_string
    adrp x20, str_lit_26
    add x20, x20, :lo12:str_lit_26
    mov x0, x20
    str x0, [sp, #-16]!
    ldr x20, [x29, #264]
    // Array.length: cargar longitud del array
    ldr w19, [x20, #0]        // longitud = array[0] (4 bytes)
    // String.valueOf() - Reservar buffer para resultado
    mov x0, #64                      // Tamaño del buffer
    bl malloc                         // Llamar a malloc
    str x0, [x29, #24]               // Guardar puntero al buffer en stack temporal (#24)
    // String.valueOf(int)
    ldr x0, [x29, #24]             // Cargar buffer desde stack
    mov x1, #64                   // tamaño del buffer
    adrp x2, .Lfmt_int            // Formato %d
    add x2, x2, :lo12:.Lfmt_int
    mov w3, w19                   // Valor int a convertir
    bl snprintf
    ldr x21, [x29, #24]             // Cargar buffer desde stack
    mov x19, x21                      // Mover resultado a x19
    mov x0, x19
    mov x1, x0
    ldr x0, [sp], #16
    // Concatenar string + string usando runtime C
    bl concat_string_string      // Llama a función C optimizada
    str x0, [sp, #-16]!
    adrp x19, str_lit_27
    add x19, x19, :lo12:str_lit_27
    mov x0, x19
    mov x1, x0
    ldr x0, [sp], #16
    // Concatenar string + string usando runtime C
    bl concat_string_string      // Llama a función C optimizada
    str x0, [sp, #-16]!
    // Cargar puntero del array desde stack
    ldr x19, [x29, #264]      // cargar puntero del array desde stack
    str x19, [sp, #-16]!  // Preservar puntero vector antes de evaluar índice
    mov w19, #0
    ldr x20, [sp], #16  // Restaurar puntero del vector desde stack
    // Acceso a matriz: matriz[index] retorna puntero
    add x22, x20, #8             // saltar header (4) + padding (4)
    add x22, x22, w19, uxtw #3   // calcular dirección: matriz + index * 8
    ldr x21, [x22]               // cargar puntero del sub-array
    // Array.length: cargar longitud del array
    ldr w19, [x21, #0]        // longitud = array[0] (4 bytes)
    // String.valueOf() - Reservar buffer para resultado
    mov x0, #64                      // Tamaño del buffer
    bl malloc                         // Llamar a malloc
    str x0, [x29, #24]               // Guardar puntero al buffer en stack temporal (#24)
    // String.valueOf(int)
    ldr x0, [x29, #24]             // Cargar buffer desde stack
    mov x1, #64                   // tamaño del buffer
    adrp x2, .Lfmt_int            // Formato %d
    add x2, x2, :lo12:.Lfmt_int
    mov w3, w19                   // Valor int a convertir
    bl snprintf
    ldr x21, [x29, #24]             // Cargar buffer desde stack
    mov x19, x21                      // Mover resultado a x19
    mov x0, x19
    mov x1, x0
    ldr x0, [sp], #16
    // Concatenar string + string usando runtime C
    bl concat_string_string      // Llama a función C optimizada
    str x0, [sp, #-16]!
    adrp x19, str_lit_28
    add x19, x19, :lo12:str_lit_28
    mov x0, x19
    mov x1, x0
    ldr x0, [sp], #16
    // Concatenar string + string usando runtime C
    bl concat_string_string      // Llama a función C optimizada
    str x0, [sp, #-16]!
    // Cargar puntero de matriz desde stack
    ldr x20, [x29, #264]
    str x20, [sp, #-16]!  // Preservar puntero matriz antes de evaluar índice fila
    mov w21, #0
    ldr x20, [sp], #16  // Restaurar puntero matriz desde stack
    // Acceso a fila: fila_ptr = matriz[fila]
    add x22, x20, #8             // saltar header de longitud
    add x22, x22, w21, uxtw #3   // offset = fila * 8
    ldr x22, [x22]               // cargar puntero de fila
    str x22, [sp, #-16]!  // Preservar puntero fila antes de evaluar índice columna
    mov w23, #0
    ldr x22, [sp], #16  // Restaurar puntero fila desde stack
    // Acceso a elemento: resultado = fila[columna]
    add x24, x22, #8             // saltar header de fila
    add x24, x24, w23, uxtw #3   // addr = fila_ptr + columna * 8
    ldr x25, [x24]               // cargar elemento desde addr
    // Array.length: cargar longitud del array
    ldr w19, [x25, #0]        // longitud = array[0] (4 bytes)
    // String.valueOf() - Reservar buffer para resultado
    mov x0, #64                      // Tamaño del buffer
    bl malloc                         // Llamar a malloc
    str x0, [x29, #24]               // Guardar puntero al buffer en stack temporal (#24)
    // String.valueOf(int)
    ldr x0, [x29, #24]             // Cargar buffer desde stack
    mov x1, #64                   // tamaño del buffer
    adrp x2, .Lfmt_int            // Formato %d
    add x2, x2, :lo12:.Lfmt_int
    mov w3, w19                   // Valor int a convertir
    bl snprintf
    ldr x21, [x29, #24]             // Cargar buffer desde stack
    mov x19, x21                      // Mover resultado a x19
    mov x0, x19
    mov x1, x0
    ldr x0, [sp], #16
    // Concatenar string + string usando runtime C
    bl concat_string_string      // Llama a función C optimizada
    bl print_string
    adrp x0, newline_29
    add x0, x0, :lo12:newline_29
    bl print_string
    adrp x19, str_lit_30
    add x19, x19, :lo12:str_lit_30
    mov x0, x19
    str x0, [sp, #-16]!
    ldr x20, [x29, #304]
    // Array.length: cargar longitud del array
    ldr w19, [x20, #0]        // longitud = array[0] (4 bytes)
    // String.valueOf() - Reservar buffer para resultado
    mov x0, #64                      // Tamaño del buffer
    bl malloc                         // Llamar a malloc
    str x0, [x29, #24]               // Guardar puntero al buffer en stack temporal (#24)
    // String.valueOf(int)
    ldr x0, [x29, #24]             // Cargar buffer desde stack
    mov x1, #64                   // tamaño del buffer
    adrp x2, .Lfmt_int            // Formato %d
    add x2, x2, :lo12:.Lfmt_int
    mov w3, w19                   // Valor int a convertir
    bl snprintf
    ldr x21, [x29, #24]             // Cargar buffer desde stack
    mov x19, x21                      // Mover resultado a x19
    mov x0, x19
    mov x1, x0
    ldr x0, [sp], #16
    // Concatenar string + string usando runtime C
    bl concat_string_string      // Llama a función C optimizada
    str x0, [sp, #-16]!
    adrp x19, str_lit_31
    add x19, x19, :lo12:str_lit_31
    mov x0, x19
    mov x1, x0
    ldr x0, [sp], #16
    // Concatenar string + string usando runtime C
    bl concat_string_string      // Llama a función C optimizada
    str x0, [sp, #-16]!
    // Cargar puntero del array desde stack
    ldr x19, [x29, #304]      // cargar puntero del array desde stack
    str x19, [sp, #-16]!  // Preservar puntero vector antes de evaluar índice
    mov w19, #0
    ldr x20, [sp], #16  // Restaurar puntero del vector desde stack
    // Acceso a matriz: matriz[index] retorna puntero
    add x22, x20, #8             // saltar header (4) + padding (4)
    add x22, x22, w19, uxtw #3   // calcular dirección: matriz + index * 8
    ldr x21, [x22]               // cargar puntero del sub-array
    // Array.length: cargar longitud del array
    ldr w19, [x21, #0]        // longitud = array[0] (4 bytes)
    // String.valueOf() - Reservar buffer para resultado
    mov x0, #64                      // Tamaño del buffer
    bl malloc                         // Llamar a malloc
    str x0, [x29, #24]               // Guardar puntero al buffer en stack temporal (#24)
    // String.valueOf(int)
    ldr x0, [x29, #24]             // Cargar buffer desde stack
    mov x1, #64                   // tamaño del buffer
    adrp x2, .Lfmt_int            // Formato %d
    add x2, x2, :lo12:.Lfmt_int
    mov w3, w19                   // Valor int a convertir
    bl snprintf
    ldr x21, [x29, #24]             // Cargar buffer desde stack
    mov x19, x21                      // Mover resultado a x19
    mov x0, x19
    mov x1, x0
    ldr x0, [sp], #16
    // Concatenar string + string usando runtime C
    bl concat_string_string      // Llama a función C optimizada
    str x0, [sp, #-16]!
    adrp x19, str_lit_32
    add x19, x19, :lo12:str_lit_32
    mov x0, x19
    mov x1, x0
    ldr x0, [sp], #16
    // Concatenar string + string usando runtime C
    bl concat_string_string      // Llama a función C optimizada
    str x0, [sp, #-16]!
    // Cargar puntero de matriz desde stack
    ldr x20, [x29, #304]
    str x20, [sp, #-16]!  // Preservar puntero matriz antes de evaluar índice fila
    mov w21, #0
    ldr x20, [sp], #16  // Restaurar puntero matriz desde stack
    // Acceso a fila: fila_ptr = matriz[fila]
    add x22, x20, #8             // saltar header de longitud
    add x22, x22, w21, uxtw #3   // offset = fila * 8
    ldr x22, [x22]               // cargar puntero de fila
    str x22, [sp, #-16]!  // Preservar puntero fila antes de evaluar índice columna
    mov w23, #0
    ldr x22, [sp], #16  // Restaurar puntero fila desde stack
    // Acceso a elemento: resultado = fila[columna]
    add x24, x22, #8             // saltar header de fila
    add x24, x24, w23, uxtw #3   // addr = fila_ptr + columna * 8
    ldr x25, [x24]               // cargar elemento desde addr
    // Array.length: cargar longitud del array
    ldr w19, [x25, #0]        // longitud = array[0] (4 bytes)
    // String.valueOf() - Reservar buffer para resultado
    mov x0, #64                      // Tamaño del buffer
    bl malloc                         // Llamar a malloc
    str x0, [x29, #24]               // Guardar puntero al buffer en stack temporal (#24)
    // String.valueOf(int)
    ldr x0, [x29, #24]             // Cargar buffer desde stack
    mov x1, #64                   // tamaño del buffer
    adrp x2, .Lfmt_int            // Formato %d
    add x2, x2, :lo12:.Lfmt_int
    mov w3, w19                   // Valor int a convertir
    bl snprintf
    ldr x21, [x29, #24]             // Cargar buffer desde stack
    mov x19, x21                      // Mover resultado a x19
    mov x0, x19
    mov x1, x0
    ldr x0, [sp], #16
    // Concatenar string + string usando runtime C
    bl concat_string_string      // Llama a función C optimizada
    bl print_string
    adrp x0, newline_33
    add x0, x0, :lo12:newline_33
    bl print_string
    adrp x19, str_lit_34
    add x19, x19, :lo12:str_lit_34
    mov x0, x19
    bl print_string
    adrp x0, newline_35
    add x0, x0, :lo12:newline_35
    bl print_string
    adrp x19, str_lit_36
    add x19, x19, :lo12:str_lit_36
    mov x0, x19
    str x0, [sp, #-16]!
    // Cargar puntero de matriz desde stack
    ldr x19, [x29, #152]
    str x19, [sp, #-16]!  // Preservar puntero matriz antes de evaluar índice fila
    mov w20, #0
    ldr x19, [sp], #16  // Restaurar puntero matriz desde stack
    // Acceso a fila: fila_ptr = matriz[fila]
    add x21, x19, #8             // saltar header de longitud
    add x21, x21, w20, uxtw #3   // offset = fila * 8
    ldr x21, [x21]               // cargar puntero de fila
    str x21, [sp, #-16]!  // Preservar puntero fila antes de evaluar índice columna
    mov w22, #1
    ldr x21, [sp], #16  // Restaurar puntero fila desde stack
    // Acceso a elemento: resultado = fila[columna]
    add x23, x21, #8             // saltar header de fila
    add x23, x23, w22, uxtw #2   // addr = fila_ptr + columna * 4
    ldr w24, [x23]               // cargar elemento desde addr
    // String.valueOf() - Reservar buffer para resultado
    mov x0, #64                      // Tamaño del buffer
    bl malloc                         // Llamar a malloc
    str x0, [x29, #24]               // Guardar puntero al buffer en stack temporal (#24)
    // String.valueOf(int)
    ldr x0, [x29, #24]             // Cargar buffer desde stack
    mov x1, #64                   // tamaño del buffer
    adrp x2, .Lfmt_int            // Formato %d
    add x2, x2, :lo12:.Lfmt_int
    mov w3, w24                   // Valor int a convertir
    bl snprintf
    ldr x21, [x29, #24]             // Cargar buffer desde stack
    mov x19, x21                      // Mover resultado a x19
    mov x0, x19
    mov x1, x0
    ldr x0, [sp], #16
    // Concatenar string + string usando runtime C
    bl concat_string_string      // Llama a función C optimizada
    bl print_string
    adrp x0, newline_37
    add x0, x0, :lo12:newline_37
    bl print_string
    // Cargar puntero de matriz desde stack para asignación
    ldr x19, [x29, #152]
    mov w20, #0
    // Obtener puntero de fila para asignación
    add x21, x19, #8             // saltar header de matriz
    add x21, x21, w20, uxtw #3   // offset = fila * 8
    ldr x21, [x21]               // cargar puntero de fila
    mov w22, #1
    mov w23, #95
    // Asignación: fila[columna] = value
    add x25, x21, #8             // saltar header de fila
    add x25, x25, w22, uxtw #2   // addr = fila_ptr + columna * 4
    str w23, [x25]               // guardar valor
    // Cargar puntero de matriz desde stack para asignación
    ldr x19, [x29, #152]
    mov w20, #2
    // Obtener puntero de fila para asignación
    add x21, x19, #8             // saltar header de matriz
    add x21, x21, w20, uxtw #3   // offset = fila * 8
    ldr x21, [x21]               // cargar puntero de fila
    mov w22, #0
    mov w23, #82
    // Asignación: fila[columna] = value
    add x25, x21, #8             // saltar header de fila
    add x25, x25, w22, uxtw #2   // addr = fila_ptr + columna * 4
    str w23, [x25]               // guardar valor
    // Cargar puntero de matriz desde stack para asignación
    ldr x19, [x29, #152]
    mov w20, #3
    // Obtener puntero de fila para asignación
    add x21, x19, #8             // saltar header de matriz
    add x21, x21, w20, uxtw #3   // offset = fila * 8
    ldr x21, [x21]               // cargar puntero de fila
    mov w22, #2
    mov w23, #90
    // Asignación: fila[columna] = value
    add x25, x21, #8             // saltar header de fila
    add x25, x25, w22, uxtw #2   // addr = fila_ptr + columna * 4
    str w23, [x25]               // guardar valor
    adrp x19, str_lit_38
    add x19, x19, :lo12:str_lit_38
    mov x0, x19
    str x0, [sp, #-16]!
    // Cargar puntero de matriz desde stack
    ldr x19, [x29, #152]
    str x19, [sp, #-16]!  // Preservar puntero matriz antes de evaluar índice fila
    mov w20, #0
    ldr x19, [sp], #16  // Restaurar puntero matriz desde stack
    // Acceso a fila: fila_ptr = matriz[fila]
    add x21, x19, #8             // saltar header de longitud
    add x21, x21, w20, uxtw #3   // offset = fila * 8
    ldr x21, [x21]               // cargar puntero de fila
    str x21, [sp, #-16]!  // Preservar puntero fila antes de evaluar índice columna
    mov w22, #1
    ldr x21, [sp], #16  // Restaurar puntero fila desde stack
    // Acceso a elemento: resultado = fila[columna]
    add x23, x21, #8             // saltar header de fila
    add x23, x23, w22, uxtw #2   // addr = fila_ptr + columna * 4
    ldr w24, [x23]               // cargar elemento desde addr
    // String.valueOf() - Reservar buffer para resultado
    mov x0, #64                      // Tamaño del buffer
    bl malloc                         // Llamar a malloc
    str x0, [x29, #24]               // Guardar puntero al buffer en stack temporal (#24)
    // String.valueOf(int)
    ldr x0, [x29, #24]             // Cargar buffer desde stack
    mov x1, #64                   // tamaño del buffer
    adrp x2, .Lfmt_int            // Formato %d
    add x2, x2, :lo12:.Lfmt_int
    mov w3, w24                   // Valor int a convertir
    bl snprintf
    ldr x21, [x29, #24]             // Cargar buffer desde stack
    mov x19, x21                      // Mover resultado a x19
    mov x0, x19
    mov x1, x0
    ldr x0, [sp], #16
    // Concatenar string + string usando runtime C
    bl concat_string_string      // Llama a función C optimizada
    bl print_string
    adrp x0, newline_39
    add x0, x0, :lo12:newline_39
    bl print_string
    adrp x19, str_lit_40
    add x19, x19, :lo12:str_lit_40
    mov x0, x19
    bl print_string
    adrp x0, newline_41
    add x0, x0, :lo12:newline_41
    bl print_string
    // Cargar puntero de matriz desde stack para asignación
    ldr x19, [x29, #184]
    mov w20, #0
    // Obtener puntero de fila para asignación
    add x21, x19, #8             // saltar header de matriz
    add x21, x21, w20, uxtw #3   // offset = fila * 8
    ldr x21, [x21]               // cargar puntero de fila
    mov w22, #0
    adrp x23, double_lit_42
    add x23, x23, :lo12:double_lit_42
    ldr d0, [x23]
    // Asignación: fila[columna] = value
    add x23, x21, #8             // saltar header de fila
    add x23, x23, w22, uxtw #2   // addr = fila_ptr + columna * 4
    str w0, [x23]               // guardar valor
    // Cargar puntero de matriz desde stack para asignación
    ldr x19, [x29, #184]
    mov w20, #0
    // Obtener puntero de fila para asignación
    add x21, x19, #8             // saltar header de matriz
    add x21, x21, w20, uxtw #3   // offset = fila * 8
    ldr x21, [x21]               // cargar puntero de fila
    mov w22, #1
    adrp x23, double_lit_43
    add x23, x23, :lo12:double_lit_43
    ldr d0, [x23]
    // Asignación: fila[columna] = value
    add x23, x21, #8             // saltar header de fila
    add x23, x23, w22, uxtw #2   // addr = fila_ptr + columna * 4
    str w0, [x23]               // guardar valor
    // Cargar puntero de matriz desde stack para asignación
    ldr x19, [x29, #184]
    mov w20, #0
    // Obtener puntero de fila para asignación
    add x21, x19, #8             // saltar header de matriz
    add x21, x21, w20, uxtw #3   // offset = fila * 8
    ldr x21, [x21]               // cargar puntero de fila
    mov w22, #2
    adrp x23, double_lit_44
    add x23, x23, :lo12:double_lit_44
    ldr d0, [x23]
    // Asignación: fila[columna] = value
    add x23, x21, #8             // saltar header de fila
    add x23, x23, w22, uxtw #2   // addr = fila_ptr + columna * 4
    str w0, [x23]               // guardar valor
    // Cargar puntero de matriz desde stack para asignación
    ldr x19, [x29, #184]
    mov w20, #1
    // Obtener puntero de fila para asignación
    add x21, x19, #8             // saltar header de matriz
    add x21, x21, w20, uxtw #3   // offset = fila * 8
    ldr x21, [x21]               // cargar puntero de fila
    mov w22, #0
    adrp x23, double_lit_45
    add x23, x23, :lo12:double_lit_45
    ldr d0, [x23]
    // Asignación: fila[columna] = value
    add x23, x21, #8             // saltar header de fila
    add x23, x23, w22, uxtw #2   // addr = fila_ptr + columna * 4
    str w0, [x23]               // guardar valor
    // Cargar puntero de matriz desde stack para asignación
    ldr x19, [x29, #184]
    mov w20, #1
    // Obtener puntero de fila para asignación
    add x21, x19, #8             // saltar header de matriz
    add x21, x21, w20, uxtw #3   // offset = fila * 8
    ldr x21, [x21]               // cargar puntero de fila
    mov w22, #1
    adrp x23, double_lit_46
    add x23, x23, :lo12:double_lit_46
    ldr d0, [x23]
    // Asignación: fila[columna] = value
    add x23, x21, #8             // saltar header de fila
    add x23, x23, w22, uxtw #2   // addr = fila_ptr + columna * 4
    str w0, [x23]               // guardar valor
    // Cargar puntero de matriz desde stack para asignación
    ldr x19, [x29, #184]
    mov w20, #1
    // Obtener puntero de fila para asignación
    add x21, x19, #8             // saltar header de matriz
    add x21, x21, w20, uxtw #3   // offset = fila * 8
    ldr x21, [x21]               // cargar puntero de fila
    mov w22, #2
    adrp x23, double_lit_47
    add x23, x23, :lo12:double_lit_47
    ldr d0, [x23]
    // Asignación: fila[columna] = value
    add x23, x21, #8             // saltar header de fila
    add x23, x23, w22, uxtw #2   // addr = fila_ptr + columna * 4
    str w0, [x23]               // guardar valor
    adrp x19, str_lit_48
    add x19, x19, :lo12:str_lit_48
    mov x0, x19
    bl print_string
    adrp x0, newline_49
    add x0, x0, :lo12:newline_49
    bl print_string
    adrp x19, str_lit_50
    add x19, x19, :lo12:str_lit_50
    mov x0, x19
    bl print_string
    adrp x0, newline_51
    add x0, x0, :lo12:newline_51
    bl print_string
    // Cargar puntero de array para asignación
    ldr x19, [x29, #264]
    mov w20, #88
    mov w21, #0
    // Nivel 0: Navegar a sub-array
    add x22, x19, #8             // Saltar header
    add x22, x22, w21, uxtw #3   // offset = index * 8
    ldr x22, [x22]               // Cargar puntero a sub-array
    mov w21, #0
    // Nivel 1: Navegar a sub-array
    add x23, x22, #8             // Saltar header
    add x23, x23, w21, uxtw #3   // offset = index * 8
    ldr x23, [x23]               // Cargar puntero a sub-array
    mov w21, #0
    // Nivel final: Escribir valor (tipo=2, shift=2)
    add x22, x23, #8             // Saltar header del array de datos
    add x22, x22, w21, uxtw #2  // addr = ptr + index * 4
    str w20, [x22]               // Escribir valor
    // Cargar puntero de array para asignación
    ldr x19, [x29, #264]
    mov w20, #92
    mov w21, #0
    // Nivel 0: Navegar a sub-array
    add x22, x19, #8             // Saltar header
    add x22, x22, w21, uxtw #3   // offset = index * 8
    ldr x22, [x22]               // Cargar puntero a sub-array
    mov w21, #0
    // Nivel 1: Navegar a sub-array
    add x23, x22, #8             // Saltar header
    add x23, x23, w21, uxtw #3   // offset = index * 8
    ldr x23, [x23]               // Cargar puntero a sub-array
    mov w21, #1
    // Nivel final: Escribir valor (tipo=2, shift=2)
    add x22, x23, #8             // Saltar header del array de datos
    add x22, x22, w21, uxtw #2  // addr = ptr + index * 4
    str w20, [x22]               // Escribir valor
    // Cargar puntero de array para asignación
    ldr x19, [x29, #264]
    mov w20, #85
    mov w21, #0
    // Nivel 0: Navegar a sub-array
    add x22, x19, #8             // Saltar header
    add x22, x22, w21, uxtw #3   // offset = index * 8
    ldr x22, [x22]               // Cargar puntero a sub-array
    mov w21, #0
    // Nivel 1: Navegar a sub-array
    add x23, x22, #8             // Saltar header
    add x23, x23, w21, uxtw #3   // offset = index * 8
    ldr x23, [x23]               // Cargar puntero a sub-array
    mov w21, #2
    // Nivel final: Escribir valor (tipo=2, shift=2)
    add x22, x23, #8             // Saltar header del array de datos
    add x22, x22, w21, uxtw #2  // addr = ptr + index * 4
    str w20, [x22]               // Escribir valor
    // Cargar puntero de array para asignación
    ldr x19, [x29, #264]
    mov w20, #85
    mov w21, #1
    // Nivel 0: Navegar a sub-array
    add x22, x19, #8             // Saltar header
    add x22, x22, w21, uxtw #3   // offset = index * 8
    ldr x22, [x22]               // Cargar puntero a sub-array
    mov w21, #1
    // Nivel 1: Navegar a sub-array
    add x23, x22, #8             // Saltar header
    add x23, x23, w21, uxtw #3   // offset = index * 8
    ldr x23, [x23]               // Cargar puntero a sub-array
    mov w21, #0
    // Nivel final: Escribir valor (tipo=2, shift=2)
    add x22, x23, #8             // Saltar header del array de datos
    add x22, x22, w21, uxtw #2  // addr = ptr + index * 4
    str w20, [x22]               // Escribir valor
    // Cargar puntero de array para asignación
    ldr x19, [x29, #264]
    mov w20, #90
    mov w21, #1
    // Nivel 0: Navegar a sub-array
    add x22, x19, #8             // Saltar header
    add x22, x22, w21, uxtw #3   // offset = index * 8
    ldr x22, [x22]               // Cargar puntero a sub-array
    mov w21, #1
    // Nivel 1: Navegar a sub-array
    add x23, x22, #8             // Saltar header
    add x23, x23, w21, uxtw #3   // offset = index * 8
    ldr x23, [x23]               // Cargar puntero a sub-array
    mov w21, #1
    // Nivel final: Escribir valor (tipo=2, shift=2)
    add x22, x23, #8             // Saltar header del array de datos
    add x22, x22, w21, uxtw #2  // addr = ptr + index * 4
    str w20, [x22]               // Escribir valor
    // Cargar puntero de array para asignación
    ldr x19, [x29, #264]
    mov w20, #88
    mov w21, #1
    // Nivel 0: Navegar a sub-array
    add x22, x19, #8             // Saltar header
    add x22, x22, w21, uxtw #3   // offset = index * 8
    ldr x22, [x22]               // Cargar puntero a sub-array
    mov w21, #1
    // Nivel 1: Navegar a sub-array
    add x23, x22, #8             // Saltar header
    add x23, x23, w21, uxtw #3   // offset = index * 8
    ldr x23, [x23]               // Cargar puntero a sub-array
    mov w21, #2
    // Nivel final: Escribir valor (tipo=2, shift=2)
    add x22, x23, #8             // Saltar header del array de datos
    add x22, x22, w21, uxtw #2  // addr = ptr + index * 4
    str w20, [x22]               // Escribir valor
    // Cargar puntero de array para asignación
    ldr x19, [x29, #264]
    mov w20, #92
    mov w21, #2
    // Nivel 0: Navegar a sub-array
    add x22, x19, #8             // Saltar header
    add x22, x22, w21, uxtw #3   // offset = index * 8
    ldr x22, [x22]               // Cargar puntero a sub-array
    mov w21, #2
    // Nivel 1: Navegar a sub-array
    add x23, x22, #8             // Saltar header
    add x23, x23, w21, uxtw #3   // offset = index * 8
    ldr x23, [x23]               // Cargar puntero a sub-array
    mov w21, #0
    // Nivel final: Escribir valor (tipo=2, shift=2)
    add x22, x23, #8             // Saltar header del array de datos
    add x22, x22, w21, uxtw #2  // addr = ptr + index * 4
    str w20, [x22]               // Escribir valor
    // Cargar puntero de array para asignación
    ldr x19, [x29, #264]
    mov w20, #87
    mov w21, #2
    // Nivel 0: Navegar a sub-array
    add x22, x19, #8             // Saltar header
    add x22, x22, w21, uxtw #3   // offset = index * 8
    ldr x22, [x22]               // Cargar puntero a sub-array
    mov w21, #2
    // Nivel 1: Navegar a sub-array
    add x23, x22, #8             // Saltar header
    add x23, x23, w21, uxtw #3   // offset = index * 8
    ldr x23, [x23]               // Cargar puntero a sub-array
    mov w21, #1
    // Nivel final: Escribir valor (tipo=2, shift=2)
    add x22, x23, #8             // Saltar header del array de datos
    add x22, x22, w21, uxtw #2  // addr = ptr + index * 4
    str w20, [x22]               // Escribir valor
    // Cargar puntero de array para asignación
    ldr x19, [x29, #264]
    mov w20, #94
    mov w21, #2
    // Nivel 0: Navegar a sub-array
    add x22, x19, #8             // Saltar header
    add x22, x22, w21, uxtw #3   // offset = index * 8
    ldr x22, [x22]               // Cargar puntero a sub-array
    mov w21, #2
    // Nivel 1: Navegar a sub-array
    add x23, x22, #8             // Saltar header
    add x23, x23, w21, uxtw #3   // offset = index * 8
    ldr x23, [x23]               // Cargar puntero a sub-array
    mov w21, #2
    // Nivel final: Escribir valor (tipo=2, shift=2)
    add x22, x23, #8             // Saltar header del array de datos
    add x22, x22, w21, uxtw #2  // addr = ptr + index * 4
    str w20, [x22]               // Escribir valor
    // Cargar puntero de array para asignación
    ldr x19, [x29, #264]
    mov w20, #96
    mov w21, #3
    // Nivel 0: Navegar a sub-array
    add x22, x19, #8             // Saltar header
    add x22, x22, w21, uxtw #3   // offset = index * 8
    ldr x22, [x22]               // Cargar puntero a sub-array
    mov w21, #3
    // Nivel 1: Navegar a sub-array
    add x23, x22, #8             // Saltar header
    add x23, x23, w21, uxtw #3   // offset = index * 8
    ldr x23, [x23]               // Cargar puntero a sub-array
    mov w21, #0
    // Nivel final: Escribir valor (tipo=2, shift=2)
    add x22, x23, #8             // Saltar header del array de datos
    add x22, x22, w21, uxtw #2  // addr = ptr + index * 4
    str w20, [x22]               // Escribir valor
    // Cargar puntero de array para asignación
    ldr x19, [x29, #264]
    mov w20, #93
    mov w21, #3
    // Nivel 0: Navegar a sub-array
    add x22, x19, #8             // Saltar header
    add x22, x22, w21, uxtw #3   // offset = index * 8
    ldr x22, [x22]               // Cargar puntero a sub-array
    mov w21, #3
    // Nivel 1: Navegar a sub-array
    add x23, x22, #8             // Saltar header
    add x23, x23, w21, uxtw #3   // offset = index * 8
    ldr x23, [x23]               // Cargar puntero a sub-array
    mov w21, #1
    // Nivel final: Escribir valor (tipo=2, shift=2)
    add x22, x23, #8             // Saltar header del array de datos
    add x22, x22, w21, uxtw #2  // addr = ptr + index * 4
    str w20, [x22]               // Escribir valor
    // Cargar puntero de array para asignación
    ldr x19, [x29, #264]
    mov w20, #97
    mov w21, #3
    // Nivel 0: Navegar a sub-array
    add x22, x19, #8             // Saltar header
    add x22, x22, w21, uxtw #3   // offset = index * 8
    ldr x22, [x22]               // Cargar puntero a sub-array
    mov w21, #3
    // Nivel 1: Navegar a sub-array
    add x23, x22, #8             // Saltar header
    add x23, x23, w21, uxtw #3   // offset = index * 8
    ldr x23, [x23]               // Cargar puntero a sub-array
    mov w21, #2
    // Nivel final: Escribir valor (tipo=2, shift=2)
    add x22, x23, #8             // Saltar header del array de datos
    add x22, x22, w21, uxtw #2  // addr = ptr + index * 4
    str w20, [x22]               // Escribir valor
    adrp x19, str_lit_52
    add x19, x19, :lo12:str_lit_52
    mov x0, x19
    bl print_string
    adrp x0, newline_53
    add x0, x0, :lo12:newline_53
    bl print_string
    adrp x19, str_lit_54
    add x19, x19, :lo12:str_lit_54
    mov x0, x19
    str x0, [sp, #-16]!
    // Cargar puntero de array multidimensional desde stack
    ldr x19, [x29, #264]
    mov w20, #0
    // Nivel 0: Navegar a sub-array
    add x21, x19, #8             // Saltar header (length + remaining_dims)
    add x21, x21, w20, uxtw #3   // offset = index * 8 (punteros)
    ldr x21, [x21]               // Cargar puntero a sub-array
    mov w20, #0
    // Nivel 1: Navegar a sub-array
    add x22, x21, #8             // Saltar header (length + remaining_dims)
    add x22, x22, w20, uxtw #3   // offset = index * 8 (punteros)
    ldr x22, [x22]               // Cargar puntero a sub-array
    mov w20, #0
    // Nivel final: Leer valor
    add x21, x22, #8             // Saltar header del array de datos
    add x21, x21, w20, uxtw #2  // addr = ptr + index * element_size
    ldr w23, [x21]               // Cargar valor
    // String.valueOf() - Reservar buffer para resultado
    mov x0, #64                      // Tamaño del buffer
    bl malloc                         // Llamar a malloc
    str x0, [x29, #24]               // Guardar puntero al buffer en stack temporal (#24)
    // String.valueOf(int)
    ldr x0, [x29, #24]             // Cargar buffer desde stack
    mov x1, #64                   // tamaño del buffer
    adrp x2, .Lfmt_int            // Formato %d
    add x2, x2, :lo12:.Lfmt_int
    mov w3, w23                   // Valor int a convertir
    bl snprintf
    ldr x21, [x29, #24]             // Cargar buffer desde stack
    mov x19, x21                      // Mover resultado a x19
    mov x0, x19
    mov x1, x0
    ldr x0, [sp], #16
    // Concatenar string + string usando runtime C
    bl concat_string_string      // Llama a función C optimizada
    str x0, [sp, #-16]!
    adrp x19, str_lit_55
    add x19, x19, :lo12:str_lit_55
    mov x0, x19
    mov x1, x0
    ldr x0, [sp], #16
    // Concatenar string + string usando runtime C
    bl concat_string_string      // Llama a función C optimizada
    str x0, [sp, #-16]!
    // Cargar puntero de array multidimensional desde stack
    ldr x19, [x29, #264]
    mov w20, #0
    // Nivel 0: Navegar a sub-array
    add x21, x19, #8             // Saltar header (length + remaining_dims)
    add x21, x21, w20, uxtw #3   // offset = index * 8 (punteros)
    ldr x21, [x21]               // Cargar puntero a sub-array
    mov w20, #0
    // Nivel 1: Navegar a sub-array
    add x22, x21, #8             // Saltar header (length + remaining_dims)
    add x22, x22, w20, uxtw #3   // offset = index * 8 (punteros)
    ldr x22, [x22]               // Cargar puntero a sub-array
    mov w20, #1
    // Nivel final: Leer valor
    add x21, x22, #8             // Saltar header del array de datos
    add x21, x21, w20, uxtw #2  // addr = ptr + index * element_size
    ldr w23, [x21]               // Cargar valor
    // String.valueOf() - Reservar buffer para resultado
    mov x0, #64                      // Tamaño del buffer
    bl malloc                         // Llamar a malloc
    str x0, [x29, #24]               // Guardar puntero al buffer en stack temporal (#24)
    // String.valueOf(int)
    ldr x0, [x29, #24]             // Cargar buffer desde stack
    mov x1, #64                   // tamaño del buffer
    adrp x2, .Lfmt_int            // Formato %d
    add x2, x2, :lo12:.Lfmt_int
    mov w3, w23                   // Valor int a convertir
    bl snprintf
    ldr x21, [x29, #24]             // Cargar buffer desde stack
    mov x19, x21                      // Mover resultado a x19
    mov x0, x19
    mov x1, x0
    ldr x0, [sp], #16
    // Concatenar string + string usando runtime C
    bl concat_string_string      // Llama a función C optimizada
    str x0, [sp, #-16]!
    adrp x19, str_lit_56
    add x19, x19, :lo12:str_lit_56
    mov x0, x19
    mov x1, x0
    ldr x0, [sp], #16
    // Concatenar string + string usando runtime C
    bl concat_string_string      // Llama a función C optimizada
    str x0, [sp, #-16]!
    // Cargar puntero de array multidimensional desde stack
    ldr x19, [x29, #264]
    mov w20, #0
    // Nivel 0: Navegar a sub-array
    add x21, x19, #8             // Saltar header (length + remaining_dims)
    add x21, x21, w20, uxtw #3   // offset = index * 8 (punteros)
    ldr x21, [x21]               // Cargar puntero a sub-array
    mov w20, #0
    // Nivel 1: Navegar a sub-array
    add x22, x21, #8             // Saltar header (length + remaining_dims)
    add x22, x22, w20, uxtw #3   // offset = index * 8 (punteros)
    ldr x22, [x22]               // Cargar puntero a sub-array
    mov w20, #2
    // Nivel final: Leer valor
    add x21, x22, #8             // Saltar header del array de datos
    add x21, x21, w20, uxtw #2  // addr = ptr + index * element_size
    ldr w23, [x21]               // Cargar valor
    // String.valueOf() - Reservar buffer para resultado
    mov x0, #64                      // Tamaño del buffer
    bl malloc                         // Llamar a malloc
    str x0, [x29, #24]               // Guardar puntero al buffer en stack temporal (#24)
    // String.valueOf(int)
    ldr x0, [x29, #24]             // Cargar buffer desde stack
    mov x1, #64                   // tamaño del buffer
    adrp x2, .Lfmt_int            // Formato %d
    add x2, x2, :lo12:.Lfmt_int
    mov w3, w23                   // Valor int a convertir
    bl snprintf
    ldr x21, [x29, #24]             // Cargar buffer desde stack
    mov x19, x21                      // Mover resultado a x19
    mov x0, x19
    mov x1, x0
    ldr x0, [sp], #16
    // Concatenar string + string usando runtime C
    bl concat_string_string      // Llama a función C optimizada
    str x0, [sp, #-16]!
    adrp x19, str_lit_57
    add x19, x19, :lo12:str_lit_57
    mov x0, x19
    mov x1, x0
    ldr x0, [sp], #16
    // Concatenar string + string usando runtime C
    bl concat_string_string      // Llama a función C optimizada
    bl print_string
    adrp x0, newline_58
    add x0, x0, :lo12:newline_58
    bl print_string
    adrp x19, str_lit_59
    add x19, x19, :lo12:str_lit_59
    mov x0, x19
    str x0, [sp, #-16]!
    // Cargar puntero de array multidimensional desde stack
    ldr x19, [x29, #264]
    mov w20, #3
    // Nivel 0: Navegar a sub-array
    add x21, x19, #8             // Saltar header (length + remaining_dims)
    add x21, x21, w20, uxtw #3   // offset = index * 8 (punteros)
    ldr x21, [x21]               // Cargar puntero a sub-array
    mov w20, #3
    // Nivel 1: Navegar a sub-array
    add x22, x21, #8             // Saltar header (length + remaining_dims)
    add x22, x22, w20, uxtw #3   // offset = index * 8 (punteros)
    ldr x22, [x22]               // Cargar puntero a sub-array
    mov w20, #0
    // Nivel final: Leer valor
    add x21, x22, #8             // Saltar header del array de datos
    add x21, x21, w20, uxtw #2  // addr = ptr + index * element_size
    ldr w23, [x21]               // Cargar valor
    // String.valueOf() - Reservar buffer para resultado
    mov x0, #64                      // Tamaño del buffer
    bl malloc                         // Llamar a malloc
    str x0, [x29, #24]               // Guardar puntero al buffer en stack temporal (#24)
    // String.valueOf(int)
    ldr x0, [x29, #24]             // Cargar buffer desde stack
    mov x1, #64                   // tamaño del buffer
    adrp x2, .Lfmt_int            // Formato %d
    add x2, x2, :lo12:.Lfmt_int
    mov w3, w23                   // Valor int a convertir
    bl snprintf
    ldr x21, [x29, #24]             // Cargar buffer desde stack
    mov x19, x21                      // Mover resultado a x19
    mov x0, x19
    mov x1, x0
    ldr x0, [sp], #16
    // Concatenar string + string usando runtime C
    bl concat_string_string      // Llama a función C optimizada
    str x0, [sp, #-16]!
    adrp x19, str_lit_60
    add x19, x19, :lo12:str_lit_60
    mov x0, x19
    mov x1, x0
    ldr x0, [sp], #16
    // Concatenar string + string usando runtime C
    bl concat_string_string      // Llama a función C optimizada
    str x0, [sp, #-16]!
    // Cargar puntero de array multidimensional desde stack
    ldr x19, [x29, #264]
    mov w20, #3
    // Nivel 0: Navegar a sub-array
    add x21, x19, #8             // Saltar header (length + remaining_dims)
    add x21, x21, w20, uxtw #3   // offset = index * 8 (punteros)
    ldr x21, [x21]               // Cargar puntero a sub-array
    mov w20, #3
    // Nivel 1: Navegar a sub-array
    add x22, x21, #8             // Saltar header (length + remaining_dims)
    add x22, x22, w20, uxtw #3   // offset = index * 8 (punteros)
    ldr x22, [x22]               // Cargar puntero a sub-array
    mov w20, #1
    // Nivel final: Leer valor
    add x21, x22, #8             // Saltar header del array de datos
    add x21, x21, w20, uxtw #2  // addr = ptr + index * element_size
    ldr w23, [x21]               // Cargar valor
    // String.valueOf() - Reservar buffer para resultado
    mov x0, #64                      // Tamaño del buffer
    bl malloc                         // Llamar a malloc
    str x0, [x29, #24]               // Guardar puntero al buffer en stack temporal (#24)
    // String.valueOf(int)
    ldr x0, [x29, #24]             // Cargar buffer desde stack
    mov x1, #64                   // tamaño del buffer
    adrp x2, .Lfmt_int            // Formato %d
    add x2, x2, :lo12:.Lfmt_int
    mov w3, w23                   // Valor int a convertir
    bl snprintf
    ldr x21, [x29, #24]             // Cargar buffer desde stack
    mov x19, x21                      // Mover resultado a x19
    mov x0, x19
    mov x1, x0
    ldr x0, [sp], #16
    // Concatenar string + string usando runtime C
    bl concat_string_string      // Llama a función C optimizada
    str x0, [sp, #-16]!
    adrp x19, str_lit_61
    add x19, x19, :lo12:str_lit_61
    mov x0, x19
    mov x1, x0
    ldr x0, [sp], #16
    // Concatenar string + string usando runtime C
    bl concat_string_string      // Llama a función C optimizada
    str x0, [sp, #-16]!
    // Cargar puntero de array multidimensional desde stack
    ldr x19, [x29, #264]
    mov w20, #3
    // Nivel 0: Navegar a sub-array
    add x21, x19, #8             // Saltar header (length + remaining_dims)
    add x21, x21, w20, uxtw #3   // offset = index * 8 (punteros)
    ldr x21, [x21]               // Cargar puntero a sub-array
    mov w20, #3
    // Nivel 1: Navegar a sub-array
    add x22, x21, #8             // Saltar header (length + remaining_dims)
    add x22, x22, w20, uxtw #3   // offset = index * 8 (punteros)
    ldr x22, [x22]               // Cargar puntero a sub-array
    mov w20, #2
    // Nivel final: Leer valor
    add x21, x22, #8             // Saltar header del array de datos
    add x21, x21, w20, uxtw #2  // addr = ptr + index * element_size
    ldr w23, [x21]               // Cargar valor
    // String.valueOf() - Reservar buffer para resultado
    mov x0, #64                      // Tamaño del buffer
    bl malloc                         // Llamar a malloc
    str x0, [x29, #24]               // Guardar puntero al buffer en stack temporal (#24)
    // String.valueOf(int)
    ldr x0, [x29, #24]             // Cargar buffer desde stack
    mov x1, #64                   // tamaño del buffer
    adrp x2, .Lfmt_int            // Formato %d
    add x2, x2, :lo12:.Lfmt_int
    mov w3, w23                   // Valor int a convertir
    bl snprintf
    ldr x21, [x29, #24]             // Cargar buffer desde stack
    mov x19, x21                      // Mover resultado a x19
    mov x0, x19
    mov x1, x0
    ldr x0, [sp], #16
    // Concatenar string + string usando runtime C
    bl concat_string_string      // Llama a función C optimizada
    str x0, [sp, #-16]!
    adrp x19, str_lit_62
    add x19, x19, :lo12:str_lit_62
    mov x0, x19
    mov x1, x0
    ldr x0, [sp], #16
    // Concatenar string + string usando runtime C
    bl concat_string_string      // Llama a función C optimizada
    bl print_string
    adrp x0, newline_63
    add x0, x0, :lo12:newline_63
    bl print_string
    // Cargar puntero de array para asignación
    ldr x19, [x29, #304]
    adrp x20, double_lit_64
    add x20, x20, :lo12:double_lit_64
    ldr d0, [x20]
    mov w20, #0
    // Nivel 0: Navegar a sub-array
    add x21, x19, #8             // Saltar header
    add x21, x21, w20, uxtw #3   // offset = index * 8
    ldr x21, [x21]               // Cargar puntero a sub-array
    mov w20, #1
    // Nivel 1: Navegar a sub-array
    add x22, x21, #8             // Saltar header
    add x22, x22, w20, uxtw #3   // offset = index * 8
    ldr x22, [x22]               // Cargar puntero a sub-array
    mov w20, #2
    // Nivel final: Escribir valor (tipo=4, shift=3)
    add x21, x22, #8             // Saltar header del array de datos
    add x21, x21, w20, uxtw #3  // addr = ptr + index * 8
    str d0, [x21]               // Escribir valor
    // Cargar puntero de array para asignación
    ldr x19, [x29, #304]
    adrp x20, double_lit_65
    add x20, x20, :lo12:double_lit_65
    ldr d0, [x20]
    mov w20, #1
    // Nivel 0: Navegar a sub-array
    add x21, x19, #8             // Saltar header
    add x21, x21, w20, uxtw #3   // offset = index * 8
    ldr x21, [x21]               // Cargar puntero a sub-array
    mov w20, #0
    // Nivel 1: Navegar a sub-array
    add x22, x21, #8             // Saltar header
    add x22, x22, w20, uxtw #3   // offset = index * 8
    ldr x22, [x22]               // Cargar puntero a sub-array
    mov w20, #1
    // Nivel final: Escribir valor (tipo=4, shift=3)
    add x21, x22, #8             // Saltar header del array de datos
    add x21, x21, w20, uxtw #3  // addr = ptr + index * 8
    str d0, [x21]               // Escribir valor
    adrp x19, str_lit_66
    add x19, x19, :lo12:str_lit_66
    mov x0, x19
    bl print_string
    adrp x0, newline_67
    add x0, x0, :lo12:newline_67
    bl print_string
    adrp x19, str_lit_68
    add x19, x19, :lo12:str_lit_68
    mov x0, x19
    bl print_string
    adrp x0, newline_69
    add x0, x0, :lo12:newline_69
    bl print_string
    // Alocar array literal 'materias' con 4 elementos (total 40 bytes)
    mov x0, #40              // tamaño total del array
    bl malloc                // alocar memoria
    mov x19, x0              // guardar puntero en registro
    mov w20, #4              // longitud del array
    str w20, [x19, #0]        // guardar longitud en array[0]
    adrp x20, str_lit_70
    add x20, x20, :lo12:str_lit_70
    str x20, [x19, #8]       // array[0] = valor
    adrp x20, str_lit_71
    add x20, x20, :lo12:str_lit_71
    str x20, [x19, #16]       // array[1] = valor
    adrp x20, str_lit_72
    add x20, x20, :lo12:str_lit_72
    str x20, [x19, #24]       // array[2] = valor
    adrp x20, str_lit_73
    add x20, x20, :lo12:str_lit_73
    str x20, [x19, #32]       // array[3] = valor
    str x19, [x29, #320]       // guardar puntero del array 'materias' en stack
    // Alocar array literal 'estudiantes' con 4 elementos (total 40 bytes)
    mov x0, #40              // tamaño total del array
    bl malloc                // alocar memoria
    mov x19, x0              // guardar puntero en registro
    mov w20, #4              // longitud del array
    str w20, [x19, #0]        // guardar longitud en array[0]
    adrp x20, str_lit_74
    add x20, x20, :lo12:str_lit_74
    str x20, [x19, #8]       // array[0] = valor
    adrp x20, str_lit_75
    add x20, x20, :lo12:str_lit_75
    str x20, [x19, #16]       // array[1] = valor
    adrp x20, str_lit_76
    add x20, x20, :lo12:str_lit_76
    str x20, [x19, #24]       // array[2] = valor
    adrp x20, str_lit_77
    add x20, x20, :lo12:str_lit_77
    str x20, [x19, #32]       // array[3] = valor
    str x19, [x29, #344]       // guardar puntero del array 'estudiantes' en stack
    adrp x19, str_lit_78
    add x19, x19, :lo12:str_lit_78
    mov x0, x19
    bl print_string
    adrp x0, newline_79
    add x0, x0, :lo12:newline_79
    bl print_string
    // Inicialización del for
    mov w19, #0
    str w19, [x29, #368]      // Guardar int 'i' en stack
for_start_9:  // Inicio del for
    ldr w19, [x29, #368]
    str w19, [sp, #-16]!         // Guardar primer operando en stack
    ldr x20, [x29, #152]      // Cargar puntero del array 'calificacionesPorMateria' desde stack
    // Array.length: cargar longitud del array
    ldr w19, [x20, #0]        // longitud = array[0] (4 bytes)
    ldr w20, [sp], #16           // Restaurar primer operando desde stack
    // Comparación INT: w20 < w19 usando runtime C
    mov w0, w20
    mov w1, w19
    bl cmp_int_lt
    // Convertir resultado string a booleano
    bl string_to_boolean
    // w0 ahora contiene 0 (false) o 1 (true)
    cbz w0, for_end_9  // Si condición es falsa, salir del for
    adrp x19, str_lit_80
    add x19, x19, :lo12:str_lit_80
    mov x0, x19
    str x0, [sp, #-16]!
    // Cargar puntero del array desde stack
    ldr x19, [x29, #344]      // cargar puntero del array desde stack
    str x19, [sp, #-16]!  // Preservar puntero vector antes de evaluar índice
    ldr w19, [x29, #368]
    ldr x20, [sp], #16  // Restaurar puntero del vector desde stack
    // Acceso a vector string: vector[index]
    add x22, x20, #8             // saltar header (4) + padding (4)
    add x22, x22, w19, uxtw #3   // calcular dirección: vector + index * 8
    ldr x21, [x22]               // cargar elemento string del vector
    mov x0, x21
    mov x1, x0
    ldr x0, [sp], #16
    // Concatenar string + string usando runtime C
    bl concat_string_string      // Llama a función C optimizada
    str x0, [sp, #-16]!
    adrp x19, str_lit_81
    add x19, x19, :lo12:str_lit_81
    mov x0, x19
    mov x1, x0
    ldr x0, [sp], #16
    // Concatenar string + string usando runtime C
    bl concat_string_string      // Llama a función C optimizada
    bl print_string
    adrp x0, newline_82
    add x0, x0, :lo12:newline_82
    bl print_string
    mov w19, #0
    str w19, [x29, #376]      // Guardar int 'suma' en stack
    // Inicialización del for
    mov w19, #0
    str w19, [x29, #384]      // Guardar int 'j' en stack
for_start_10:  // Inicio del for
    ldr w19, [x29, #384]
    str w19, [sp, #-16]!         // Guardar primer operando en stack
    // Cargar puntero del array desde stack
    ldr x19, [x29, #152]      // cargar puntero del array desde stack
    str x19, [sp, #-16]!  // Preservar puntero vector antes de evaluar índice
    ldr w19, [x29, #368]
    ldr x20, [sp], #16  // Restaurar puntero del vector desde stack
    // Acceso a matriz: matriz[index] retorna puntero
    add x22, x20, #8             // saltar header (4) + padding (4)
    add x22, x22, w19, uxtw #3   // calcular dirección: matriz + index * 8
    ldr x21, [x22]               // cargar puntero del sub-array
    // Array.length: cargar longitud del array
    ldr w19, [x21, #0]        // longitud = array[0] (4 bytes)
    ldr w20, [sp], #16           // Restaurar primer operando desde stack
    // Comparación INT: w20 < w19 usando runtime C
    mov w0, w20
    mov w1, w19
    bl cmp_int_lt
    // Convertir resultado string a booleano
    bl string_to_boolean
    // w0 ahora contiene 0 (false) o 1 (true)
    cbz w0, for_end_10  // Si condición es falsa, salir del for
    // Cargar puntero de matriz desde stack
    ldr x19, [x29, #152]
    str x19, [sp, #-16]!  // Preservar puntero matriz antes de evaluar índice fila
    ldr w20, [x29, #368]
    ldr x19, [sp], #16  // Restaurar puntero matriz desde stack
    // Acceso a fila: fila_ptr = matriz[fila]
    add x21, x19, #8             // saltar header de longitud
    add x21, x21, w20, uxtw #3   // offset = fila * 8
    ldr x21, [x21]               // cargar puntero de fila
    str x21, [sp, #-16]!  // Preservar puntero fila antes de evaluar índice columna
    ldr w22, [x29, #384]
    ldr x21, [sp], #16  // Restaurar puntero fila desde stack
    // Acceso a elemento: resultado = fila[columna]
    add x23, x21, #8             // saltar header de fila
    add x23, x23, w22, uxtw #2   // addr = fila_ptr + columna * 4
    ldr w24, [x23]               // cargar elemento desde addr
    str w24, [x29, #392]      // Guardar int 'nota' en stack
    adrp x19, str_lit_83
    add x19, x19, :lo12:str_lit_83
    mov x0, x19
    str x0, [sp, #-16]!
    // Cargar puntero del array desde stack
    ldr x19, [x29, #320]      // cargar puntero del array desde stack
    str x19, [sp, #-16]!  // Preservar puntero vector antes de evaluar índice
    ldr w19, [x29, #384]
    ldr x20, [sp], #16  // Restaurar puntero del vector desde stack
    // Acceso a vector string: vector[index]
    add x22, x20, #8             // saltar header (4) + padding (4)
    add x22, x22, w19, uxtw #3   // calcular dirección: vector + index * 8
    ldr x21, [x22]               // cargar elemento string del vector
    mov x0, x21
    mov x1, x0
    ldr x0, [sp], #16
    // Concatenar string + string usando runtime C
    bl concat_string_string      // Llama a función C optimizada
    str x0, [sp, #-16]!
    adrp x19, str_lit_84
    add x19, x19, :lo12:str_lit_84
    mov x0, x19
    mov x1, x0
    ldr x0, [sp], #16
    // Concatenar string + string usando runtime C
    bl concat_string_string      // Llama a función C optimizada
    str x0, [sp, #-16]!
    ldr w19, [x29, #392]
    // String.valueOf() - Reservar buffer para resultado
    mov x0, #64                      // Tamaño del buffer
    bl malloc                         // Llamar a malloc
    str x0, [x29, #24]               // Guardar puntero al buffer en stack temporal (#24)
    // String.valueOf(int)
    ldr x0, [x29, #24]             // Cargar buffer desde stack
    mov x1, #64                   // tamaño del buffer
    adrp x2, .Lfmt_int            // Formato %d
    add x2, x2, :lo12:.Lfmt_int
    mov w3, w19                   // Valor int a convertir
    bl snprintf
    ldr x21, [x29, #24]             // Cargar buffer desde stack
    mov x19, x21                      // Mover resultado a x19
    mov x0, x19
    mov x1, x0
    ldr x0, [sp], #16
    // Concatenar string + string usando runtime C
    bl concat_string_string      // Llama a función C optimizada
    bl print_string
    adrp x0, newline_85
    add x0, x0, :lo12:newline_85
    bl print_string
    ldr w19, [x29, #392]
    ldr w28, [x29, #376]  // Cargar suma (int/bool/char)
    add w28, w28, w19  // suma += ...
    str w28, [x29, #376]  // Guardar resultado en suma
for_continue_10:  // Continue del for (actualización)
    // Actualización del for
    ldr w20, [x29, #384]
    str w20, [x29, #400]  // Preservar operando izq (prof=0)
    mov w21, #1
    ldr w20, [x29, #400]  // Restaurar operando izq (prof=0)
    add w22, w20, w21
    str w22, [x29, #384]      // Guardar int 'j' en stack
    b for_start_10  // Volver al inicio del for
for_end_10:  // Fin del for
    ldr w20, [x29, #376]
    scvtf d0, w20  // Convertir int a double (operando izquierdo)
    sub sp, sp, #16
    str d0, [sp]
    // Cargar puntero del array desde stack
    ldr x19, [x29, #152]      // cargar puntero del array desde stack
    str x19, [sp, #-16]!  // Preservar puntero vector antes de evaluar índice
    ldr w19, [x29, #368]
    ldr x20, [sp], #16  // Restaurar puntero del vector desde stack
    // Acceso a matriz: matriz[index] retorna puntero
    add x22, x20, #8             // saltar header (4) + padding (4)
    add x22, x22, w19, uxtw #3   // calcular dirección: matriz + index * 8
    ldr x21, [x22]               // cargar puntero del sub-array
    // Array.length: cargar longitud del array
    ldr w19, [x21, #0]        // longitud = array[0] (4 bytes)
    # int -> double (widening)
    scvtf d0, w19
    fmov d1, d0
    ldr d0, [sp]
    add sp, sp, #16
    fdiv d0, d0, d1
    str d0, [x29, #400]      // Guardar double 'promedio' en stack
    adrp x19, str_lit_86
    add x19, x19, :lo12:str_lit_86
    mov x0, x19
    str x0, [sp, #-16]!
    ldr d0, [x29, #400]
    // Preservar d0 antes de malloc
    str d0, [x29, #16]                // Guardar double en stack temporal
    // String.valueOf() - Reservar buffer para resultado
    mov x0, #64                      // Tamaño del buffer
    bl malloc                         // Llamar a malloc
    str x0, [x29, #24]               // Guardar puntero al buffer en stack temporal (#24)
    // String.valueOf(double)
    ldr d0, [x29, #16]            // Cargar double desde stack temporal
    bl format_double              // Llamar a runtime C (argumento en d0)
    str x0, [x29, #24]            // Guardar resultado en stack (#24)
    ldr x21, [x29, #24]             // Cargar buffer desde stack
    mov x19, x21                      // Mover resultado a x19
    mov x0, x19
    mov x1, x0
    ldr x0, [sp], #16
    // Concatenar string + string usando runtime C
    bl concat_string_string      // Llama a función C optimizada
    bl print_string
    adrp x0, newline_87
    add x0, x0, :lo12:newline_87
    bl print_string
    adrp x0, newline_88
    add x0, x0, :lo12:newline_88
    bl print_string
for_continue_9:  // Continue del for (actualización)
    // Actualización del for
    ldr w19, [x29, #368]
    str w19, [x29, #408]  // Preservar operando izq (prof=0)
    mov w20, #1
    ldr w19, [x29, #408]  // Restaurar operando izq (prof=0)
    add w21, w19, w20
    str w21, [x29, #368]      // Guardar int 'i' en stack
    b for_start_9  // Volver al inicio del for
for_end_9:  // Fin del for
    adrp x19, str_lit_89
    add x19, x19, :lo12:str_lit_89
    mov x0, x19
    bl print_string
    adrp x0, newline_90
    add x0, x0, :lo12:newline_90
    bl print_string
    adrp x19, str_lit_91
    add x19, x19, :lo12:str_lit_91
    mov x0, x19
    str x0, [sp, #-16]!
    // Cargar puntero de matriz desde stack
    ldr x19, [x29, #152]
    str x19, [sp, #-16]!  // Preservar puntero matriz antes de evaluar índice fila
    mov w20, #0
    ldr x19, [sp], #16  // Restaurar puntero matriz desde stack
    // Acceso a fila: fila_ptr = matriz[fila]
    add x21, x19, #8             // saltar header de longitud
    add x21, x21, w20, uxtw #3   // offset = fila * 8
    ldr x21, [x21]               // cargar puntero de fila
    str x21, [sp, #-16]!  // Preservar puntero fila antes de evaluar índice columna
    mov w22, #0
    ldr x21, [sp], #16  // Restaurar puntero fila desde stack
    // Acceso a elemento: resultado = fila[columna]
    add x23, x21, #8             // saltar header de fila
    add x23, x23, w22, uxtw #2   // addr = fila_ptr + columna * 4
    ldr w24, [x23]               // cargar elemento desde addr
    // String.valueOf() - Reservar buffer para resultado
    mov x0, #64                      // Tamaño del buffer
    bl malloc                         // Llamar a malloc
    str x0, [x29, #24]               // Guardar puntero al buffer en stack temporal (#24)
    // String.valueOf(int)
    ldr x0, [x29, #24]             // Cargar buffer desde stack
    mov x1, #64                   // tamaño del buffer
    adrp x2, .Lfmt_int            // Formato %d
    add x2, x2, :lo12:.Lfmt_int
    mov w3, w24                   // Valor int a convertir
    bl snprintf
    ldr x21, [x29, #24]             // Cargar buffer desde stack
    mov x19, x21                      // Mover resultado a x19
    mov x0, x19
    mov x1, x0
    ldr x0, [sp], #16
    // Concatenar string + string usando runtime C
    bl concat_string_string      // Llama a función C optimizada
    bl print_string
    adrp x0, newline_92
    add x0, x0, :lo12:newline_92
    bl print_string
    adrp x19, str_lit_93
    add x19, x19, :lo12:str_lit_93
    mov x0, x19
    str x0, [sp, #-16]!
    // Cargar puntero de matriz desde stack
    ldr x19, [x29, #152]
    str x19, [sp, #-16]!  // Preservar puntero matriz antes de evaluar índice fila
    ldr x20, [x29, #344]      // Cargar puntero del array 'estudiantes' desde stack
    // Array.length: cargar longitud del array
    ldr w19, [x20, #0]        // longitud = array[0] (4 bytes)
    str w19, [x29, #408]  // Preservar operando izq resta (prof=0)
    mov w20, #1
    ldr w19, [x29, #408]  // Restaurar operando izq resta (prof=0)
    sub w21, w19, w20
    ldr x19, [sp], #16  // Restaurar puntero matriz desde stack
    // Acceso a fila: fila_ptr = matriz[fila]
    add x19, x19, #8             // saltar header de longitud
    add x19, x19, w21, uxtw #3   // offset = fila * 8
    ldr x19, [x19]               // cargar puntero de fila
    str x19, [sp, #-16]!  // Preservar puntero fila antes de evaluar índice columna
    ldr x20, [x29, #320]      // Cargar puntero del array 'materias' desde stack
    // Array.length: cargar longitud del array
    ldr w19, [x20, #0]        // longitud = array[0] (4 bytes)
    str w19, [x29, #408]  // Preservar operando izq resta (prof=0)
    mov w20, #1
    ldr w19, [x29, #408]  // Restaurar operando izq resta (prof=0)
    sub w21, w19, w20
    ldr x19, [sp], #16  // Restaurar puntero fila desde stack
    // Acceso a elemento: resultado = fila[columna]
    add x19, x19, #8             // saltar header de fila
    add x19, x19, w21, uxtw #2   // addr = fila_ptr + columna * 4
    ldr w20, [x19]               // cargar elemento desde addr
    // String.valueOf() - Reservar buffer para resultado
    mov x0, #64                      // Tamaño del buffer
    bl malloc                         // Llamar a malloc
    str x0, [x29, #24]               // Guardar puntero al buffer en stack temporal (#24)
    // String.valueOf(int)
    ldr x0, [x29, #24]             // Cargar buffer desde stack
    mov x1, #64                   // tamaño del buffer
    adrp x2, .Lfmt_int            // Formato %d
    add x2, x2, :lo12:.Lfmt_int
    mov w3, w20                   // Valor int a convertir
    bl snprintf
    ldr x21, [x29, #24]             // Cargar buffer desde stack
    mov x19, x21                      // Mover resultado a x19
    mov x0, x19
    mov x1, x0
    ldr x0, [sp], #16
    // Concatenar string + string usando runtime C
    bl concat_string_string      // Llama a función C optimizada
    bl print_string
    adrp x0, newline_94
    add x0, x0, :lo12:newline_94
    bl print_string
    adrp x19, str_lit_95
    add x19, x19, :lo12:str_lit_95
    mov x0, x19
    str x0, [sp, #-16]!
    // Cargar puntero de matriz desde stack
    ldr x19, [x29, #152]
    str x19, [sp, #-16]!  // Preservar puntero matriz antes de evaluar índice fila
    ldr x20, [x29, #344]      // Cargar puntero del array 'estudiantes' desde stack
    // Array.length: cargar longitud del array
    ldr w19, [x20, #0]        // longitud = array[0] (4 bytes)
    mov w20, #2
    sdiv w21, w19, w20
    ldr x19, [sp], #16  // Restaurar puntero matriz desde stack
    // Acceso a fila: fila_ptr = matriz[fila]
    add x19, x19, #8             // saltar header de longitud
    add x19, x19, w21, uxtw #3   // offset = fila * 8
    ldr x19, [x19]               // cargar puntero de fila
    str x19, [sp, #-16]!  // Preservar puntero fila antes de evaluar índice columna
    ldr x20, [x29, #320]      // Cargar puntero del array 'materias' desde stack
    // Array.length: cargar longitud del array
    ldr w19, [x20, #0]        // longitud = array[0] (4 bytes)
    mov w20, #2
    sdiv w21, w19, w20
    ldr x19, [sp], #16  // Restaurar puntero fila desde stack
    // Acceso a elemento: resultado = fila[columna]
    add x19, x19, #8             // saltar header de fila
    add x19, x19, w21, uxtw #2   // addr = fila_ptr + columna * 4
    ldr w20, [x19]               // cargar elemento desde addr
    // String.valueOf() - Reservar buffer para resultado
    mov x0, #64                      // Tamaño del buffer
    bl malloc                         // Llamar a malloc
    str x0, [x29, #24]               // Guardar puntero al buffer en stack temporal (#24)
    // String.valueOf(int)
    ldr x0, [x29, #24]             // Cargar buffer desde stack
    mov x1, #64                   // tamaño del buffer
    adrp x2, .Lfmt_int            // Formato %d
    add x2, x2, :lo12:.Lfmt_int
    mov w3, w20                   // Valor int a convertir
    bl snprintf
    ldr x21, [x29, #24]             // Cargar buffer desde stack
    mov x19, x21                      // Mover resultado a x19
    mov x0, x19
    mov x1, x0
    ldr x0, [sp], #16
    // Concatenar string + string usando runtime C
    bl concat_string_string      // Llama a función C optimizada
    bl print_string
    adrp x0, newline_96
    add x0, x0, :lo12:newline_96
    bl print_string
    adrp x19, str_lit_97
    add x19, x19, :lo12:str_lit_97
    mov x0, x19
    bl print_string
    adrp x0, newline_98
    add x0, x0, :lo12:newline_98
    bl print_string
    adrp x19, str_lit_99
    add x19, x19, :lo12:str_lit_99
    mov x0, x19
    bl print_string
    adrp x0, newline_100
    add x0, x0, :lo12:newline_100
    bl print_string
    // Alocar array literal 'tiposEvaluacion' con 3 elementos (total 32 bytes)
    mov x0, #32              // tamaño total del array
    bl malloc                // alocar memoria
    mov x19, x0              // guardar puntero en registro
    mov w21, #3              // longitud del array
    str w21, [x19, #0]        // guardar longitud en array[0]
    adrp x21, str_lit_101
    add x21, x21, :lo12:str_lit_101
    str x21, [x19, #8]       // array[0] = valor
    adrp x21, str_lit_102
    add x21, x21, :lo12:str_lit_102
    str x21, [x19, #16]       // array[1] = valor
    adrp x21, str_lit_103
    add x21, x21, :lo12:str_lit_103
    str x21, [x19, #24]       // array[2] = valor
    str x19, [x29, #408]       // guardar puntero del array 'tiposEvaluacion' en stack
    // Inicialización del for
    mov w19, #0
    str w19, [x29, #432]      // Guardar int 'estudiante' en stack
for_start_11:  // Inicio del for
    ldr w19, [x29, #432]
    str w19, [sp, #-16]!         // Guardar primer operando en stack
    mov w21, #2
    ldr w22, [sp], #16           // Restaurar primer operando desde stack
    // Comparación INT: w22 < w21 usando runtime C
    mov w0, w22
    mov w1, w21
    bl cmp_int_lt
    // Convertir resultado string a booleano
    bl string_to_boolean
    // w0 ahora contiene 0 (false) o 1 (true)
    cbz w0, for_end_11  // Si condición es falsa, salir del for
    adrp x19, str_lit_104
    add x19, x19, :lo12:str_lit_104
    mov x0, x19
    str x0, [sp, #-16]!
    // Cargar puntero del array desde stack
    ldr x19, [x29, #344]      // cargar puntero del array desde stack
    str x19, [sp, #-16]!  // Preservar puntero vector antes de evaluar índice
    ldr w19, [x29, #432]
    ldr x20, [sp], #16  // Restaurar puntero del vector desde stack
    // Acceso a vector string: vector[index]
    add x22, x20, #8             // saltar header (4) + padding (4)
    add x22, x22, w19, uxtw #3   // calcular dirección: vector + index * 8
    ldr x21, [x22]               // cargar elemento string del vector
    mov x0, x21
    mov x1, x0
    ldr x0, [sp], #16
    // Concatenar string + string usando runtime C
    bl concat_string_string      // Llama a función C optimizada
    str x0, [sp, #-16]!
    adrp x19, str_lit_105
    add x19, x19, :lo12:str_lit_105
    mov x0, x19
    mov x1, x0
    ldr x0, [sp], #16
    // Concatenar string + string usando runtime C
    bl concat_string_string      // Llama a función C optimizada
    bl print_string
    adrp x0, newline_106
    add x0, x0, :lo12:newline_106
    bl print_string
    // Inicialización del for
    mov w19, #0
    str w19, [x29, #440]      // Guardar int 'materia' en stack
for_start_12:  // Inicio del for
    ldr w19, [x29, #440]
    str w19, [sp, #-16]!         // Guardar primer operando en stack
    mov w20, #2
    ldr w21, [sp], #16           // Restaurar primer operando desde stack
    // Comparación INT: w21 < w20 usando runtime C
    mov w0, w21
    mov w1, w20
    bl cmp_int_lt
    // Convertir resultado string a booleano
    bl string_to_boolean
    // w0 ahora contiene 0 (false) o 1 (true)
    cbz w0, for_end_12  // Si condición es falsa, salir del for
    adrp x19, str_lit_107
    add x19, x19, :lo12:str_lit_107
    mov x0, x19
    str x0, [sp, #-16]!
    // Cargar puntero del array desde stack
    ldr x19, [x29, #320]      // cargar puntero del array desde stack
    str x19, [sp, #-16]!  // Preservar puntero vector antes de evaluar índice
    ldr w19, [x29, #440]
    ldr x20, [sp], #16  // Restaurar puntero del vector desde stack
    // Acceso a vector string: vector[index]
    add x22, x20, #8             // saltar header (4) + padding (4)
    add x22, x22, w19, uxtw #3   // calcular dirección: vector + index * 8
    ldr x21, [x22]               // cargar elemento string del vector
    mov x0, x21
    mov x1, x0
    ldr x0, [sp], #16
    // Concatenar string + string usando runtime C
    bl concat_string_string      // Llama a función C optimizada
    str x0, [sp, #-16]!
    adrp x19, str_lit_108
    add x19, x19, :lo12:str_lit_108
    mov x0, x19
    mov x1, x0
    ldr x0, [sp], #16
    // Concatenar string + string usando runtime C
    bl concat_string_string      // Llama a función C optimizada
    bl print_string
    adrp x0, newline_109
    add x0, x0, :lo12:newline_109
    bl print_string
    // Inicialización del for
    mov w19, #0
    str w19, [x29, #448]      // Guardar int 'evaluacion' en stack
for_start_13:  // Inicio del for
    ldr w19, [x29, #448]
    str w19, [sp, #-16]!         // Guardar primer operando en stack
    // Cargar puntero de matriz desde stack
    ldr x20, [x29, #264]
    str x20, [sp, #-16]!  // Preservar puntero matriz antes de evaluar índice fila
    ldr w21, [x29, #432]
    ldr x20, [sp], #16  // Restaurar puntero matriz desde stack
    // Acceso a fila: fila_ptr = matriz[fila]
    add x22, x20, #8             // saltar header de longitud
    add x22, x22, w21, uxtw #3   // offset = fila * 8
    ldr x22, [x22]               // cargar puntero de fila
    str x22, [sp, #-16]!  // Preservar puntero fila antes de evaluar índice columna
    ldr w23, [x29, #440]
    ldr x22, [sp], #16  // Restaurar puntero fila desde stack
    // Acceso a elemento: resultado = fila[columna]
    add x24, x22, #8             // saltar header de fila
    add x24, x24, w23, uxtw #3   // addr = fila_ptr + columna * 8
    ldr x25, [x24]               // cargar elemento desde addr
    // Array.length: cargar longitud del array
    ldr w19, [x25, #0]        // longitud = array[0] (4 bytes)
    ldr w20, [sp], #16           // Restaurar primer operando desde stack
    // Comparación INT: w20 < w19 usando runtime C
    mov w0, w20
    mov w1, w19
    bl cmp_int_lt
    // Convertir resultado string a booleano
    bl string_to_boolean
    // w0 ahora contiene 0 (false) o 1 (true)
    cbz w0, for_end_13  // Si condición es falsa, salir del for
    // Cargar puntero de array multidimensional desde stack
    ldr x19, [x29, #264]
    ldr w20, [x29, #432]
    // Nivel 0: Navegar a sub-array
    add x21, x19, #8             // Saltar header (length + remaining_dims)
    add x21, x21, w20, uxtw #3   // offset = index * 8 (punteros)
    ldr x21, [x21]               // Cargar puntero a sub-array
    ldr w20, [x29, #440]
    // Nivel 1: Navegar a sub-array
    add x22, x21, #8             // Saltar header (length + remaining_dims)
    add x22, x22, w20, uxtw #3   // offset = index * 8 (punteros)
    ldr x22, [x22]               // Cargar puntero a sub-array
    ldr w20, [x29, #448]
    // Nivel final: Leer valor
    add x21, x22, #8             // Saltar header del array de datos
    add x21, x21, w20, uxtw #2  // addr = ptr + index * element_size
    ldr w23, [x21]               // Cargar valor
    str w23, [x29, #456]      // Guardar int 'nota' en stack
    // ===== IF statement (label 1) =====
    ldr w20, [x29, #456]
    str w20, [sp, #-16]!         // Guardar primer operando en stack
    mov w21, #0
    ldr w22, [sp], #16           // Restaurar primer operando desde stack
    // Comparación INT: w22 > w21 usando runtime C
    mov w0, w22
    mov w1, w21
    bl cmp_int_gt
    // Convertir resultado string a booleano
    bl string_to_boolean
    // w0 ahora contiene 0 (false) o 1 (true)
    cbz w0, .Lend_if_1          // Si false, ir al final
    adrp x20, str_lit_110
    add x20, x20, :lo12:str_lit_110
    mov x0, x20
    str x0, [sp, #-16]!
    // Cargar puntero del array desde stack
    ldr x19, [x29, #408]      // cargar puntero del array desde stack
    str x19, [sp, #-16]!  // Preservar puntero vector antes de evaluar índice
    ldr w19, [x29, #448]
    ldr x20, [sp], #16  // Restaurar puntero del vector desde stack
    // Acceso a vector string: vector[index]
    add x22, x20, #8             // saltar header (4) + padding (4)
    add x22, x22, w19, uxtw #3   // calcular dirección: vector + index * 8
    ldr x21, [x22]               // cargar elemento string del vector
    mov x0, x21
    mov x1, x0
    ldr x0, [sp], #16
    // Concatenar string + string usando runtime C
    bl concat_string_string      // Llama a función C optimizada
    str x0, [sp, #-16]!
    adrp x19, str_lit_111
    add x19, x19, :lo12:str_lit_111
    mov x0, x19
    mov x1, x0
    ldr x0, [sp], #16
    // Concatenar string + string usando runtime C
    bl concat_string_string      // Llama a función C optimizada
    str x0, [sp, #-16]!
    ldr w19, [x29, #456]
    // String.valueOf() - Reservar buffer para resultado
    mov x0, #64                      // Tamaño del buffer
    bl malloc                         // Llamar a malloc
    str x0, [x29, #24]               // Guardar puntero al buffer en stack temporal (#24)
    // String.valueOf(int)
    ldr x0, [x29, #24]             // Cargar buffer desde stack
    mov x1, #64                   // tamaño del buffer
    adrp x2, .Lfmt_int            // Formato %d
    add x2, x2, :lo12:.Lfmt_int
    mov w3, w19                   // Valor int a convertir
    bl snprintf
    ldr x21, [x29, #24]             // Cargar buffer desde stack
    mov x19, x21                      // Mover resultado a x19
    mov x0, x19
    mov x1, x0
    ldr x0, [sp], #16
    // Concatenar string + string usando runtime C
    bl concat_string_string      // Llama a función C optimizada
    bl print_string
    adrp x0, newline_112
    add x0, x0, :lo12:newline_112
    bl print_string
.Lend_if_1:                      // Fin del if
for_continue_13:  // Continue del for (actualización)
    // Actualización del for
    ldr w19, [x29, #448]
    str w19, [x29, #464]  // Preservar operando izq (prof=0)
    mov w20, #1
    ldr w19, [x29, #464]  // Restaurar operando izq (prof=0)
    add w21, w19, w20
    str w21, [x29, #448]      // Guardar int 'evaluacion' en stack
    b for_start_13  // Volver al inicio del for
for_end_13:  // Fin del for
for_continue_12:  // Continue del for (actualización)
    // Actualización del for
    ldr w19, [x29, #440]
    str w19, [x29, #464]  // Preservar operando izq (prof=0)
    mov w20, #1
    ldr w19, [x29, #464]  // Restaurar operando izq (prof=0)
    add w21, w19, w20
    str w21, [x29, #440]      // Guardar int 'materia' en stack
    b for_start_12  // Volver al inicio del for
for_end_12:  // Fin del for
    adrp x0, newline_113
    add x0, x0, :lo12:newline_113
    bl print_string
for_continue_11:  // Continue del for (actualización)
    // Actualización del for
    ldr w19, [x29, #432]
    str w19, [x29, #464]  // Preservar operando izq (prof=0)
    mov w20, #1
    ldr w19, [x29, #464]  // Restaurar operando izq (prof=0)
    add w21, w19, w20
    str w21, [x29, #432]      // Guardar int 'estudiante' en stack
    b for_start_11  // Volver al inicio del for
for_end_11:  // Fin del for
    adrp x19, str_lit_114
    add x19, x19, :lo12:str_lit_114
    mov x0, x19
    bl print_string
    adrp x0, newline_115
    add x0, x0, :lo12:newline_115
    bl print_string
    // Alocar array literal 'semanas' con 2 elementos (total 24 bytes)
    mov x0, #24              // tamaño total del array
    bl malloc                // alocar memoria
    mov x19, x0              // guardar puntero en registro
    mov w20, #2              // longitud del array
    str w20, [x19, #0]        // guardar longitud en array[0]
    adrp x20, str_lit_116
    add x20, x20, :lo12:str_lit_116
    str x20, [x19, #8]       // array[0] = valor
    adrp x20, str_lit_117
    add x20, x20, :lo12:str_lit_117
    str x20, [x19, #16]       // array[1] = valor
    str x19, [x29, #464]       // guardar puntero del array 'semanas' en stack
    // Alocar array literal 'dias' con 3 elementos (total 32 bytes)
    mov x0, #32              // tamaño total del array
    bl malloc                // alocar memoria
    mov x19, x0              // guardar puntero en registro
    mov w20, #3              // longitud del array
    str w20, [x19, #0]        // guardar longitud en array[0]
    adrp x20, str_lit_118
    add x20, x20, :lo12:str_lit_118
    str x20, [x19, #8]       // array[0] = valor
    adrp x20, str_lit_119
    add x20, x20, :lo12:str_lit_119
    str x20, [x19, #16]       // array[1] = valor
    adrp x20, str_lit_120
    add x20, x20, :lo12:str_lit_120
    str x20, [x19, #24]       // array[2] = valor
    str x19, [x29, #488]       // guardar puntero del array 'dias' en stack
    // Alocar array literal 'periodos' con 3 elementos (total 32 bytes)
    mov x0, #32              // tamaño total del array
    bl malloc                // alocar memoria
    mov x19, x0              // guardar puntero en registro
    mov w20, #3              // longitud del array
    str w20, [x19, #0]        // guardar longitud en array[0]
    adrp x20, str_lit_121
    add x20, x20, :lo12:str_lit_121
    str x20, [x19, #8]       // array[0] = valor
    adrp x20, str_lit_122
    add x20, x20, :lo12:str_lit_122
    str x20, [x19, #16]       // array[1] = valor
    adrp x20, str_lit_123
    add x20, x20, :lo12:str_lit_123
    str x20, [x19, #24]       // array[2] = valor
    str x19, [x29, #512]       // guardar puntero del array 'periodos' en stack
    // Inicialización del for
    mov w19, #0
    str w19, [x29, #536]      // Guardar int 'semana' en stack
for_start_14:  // Inicio del for
    ldr w19, [x29, #536]
    str w19, [sp, #-16]!         // Guardar primer operando en stack
    ldr x20, [x29, #304]
    // Array.length: cargar longitud del array
    ldr w19, [x20, #0]        // longitud = array[0] (4 bytes)
    ldr w20, [sp], #16           // Restaurar primer operando desde stack
    // Comparación INT: w20 < w19 usando runtime C
    mov w0, w20
    mov w1, w19
    bl cmp_int_lt
    // Convertir resultado string a booleano
    bl string_to_boolean
    // w0 ahora contiene 0 (false) o 1 (true)
    cbz w0, for_end_14  // Si condición es falsa, salir del for
    // Cargar puntero del array desde stack
    ldr x19, [x29, #464]      // cargar puntero del array desde stack
    str x19, [sp, #-16]!  // Preservar puntero vector antes de evaluar índice
    ldr w19, [x29, #536]
    ldr x20, [sp], #16  // Restaurar puntero del vector desde stack
    // Acceso a vector string: vector[index]
    add x22, x20, #8             // saltar header (4) + padding (4)
    add x22, x22, w19, uxtw #3   // calcular dirección: vector + index * 8
    ldr x21, [x22]               // cargar elemento string del vector
    mov x0, x21
    str x0, [sp, #-16]!
    adrp x19, str_lit_124
    add x19, x19, :lo12:str_lit_124
    mov x0, x19
    mov x1, x0
    ldr x0, [sp], #16
    // Concatenar string + string usando runtime C
    bl concat_string_string      // Llama a función C optimizada
    bl print_string
    adrp x0, newline_125
    add x0, x0, :lo12:newline_125
    bl print_string
    // Inicialización del for
    mov w19, #0
    str w19, [x29, #544]      // Guardar int 'dia' en stack
for_start_15:  // Inicio del for
    ldr w19, [x29, #544]
    str w19, [sp, #-16]!         // Guardar primer operando en stack
    // Cargar puntero del array desde stack
    ldr x19, [x29, #304]      // cargar puntero del array desde stack
    str x19, [sp, #-16]!  // Preservar puntero vector antes de evaluar índice
    ldr w19, [x29, #536]
    ldr x20, [sp], #16  // Restaurar puntero del vector desde stack
    // Acceso a matriz: matriz[index] retorna puntero
    add x22, x20, #8             // saltar header (4) + padding (4)
    add x22, x22, w19, uxtw #3   // calcular dirección: matriz + index * 8
    ldr x21, [x22]               // cargar puntero del sub-array
    // Array.length: cargar longitud del array
    ldr w19, [x21, #0]        // longitud = array[0] (4 bytes)
    ldr w20, [sp], #16           // Restaurar primer operando desde stack
    // Comparación INT: w20 < w19 usando runtime C
    mov w0, w20
    mov w1, w19
    bl cmp_int_lt
    // Convertir resultado string a booleano
    bl string_to_boolean
    // w0 ahora contiene 0 (false) o 1 (true)
    cbz w0, for_end_15  // Si condición es falsa, salir del for
    adrp x19, str_lit_126
    add x19, x19, :lo12:str_lit_126
    mov x0, x19
    str x0, [sp, #-16]!
    // Cargar puntero del array desde stack
    ldr x19, [x29, #488]      // cargar puntero del array desde stack
    str x19, [sp, #-16]!  // Preservar puntero vector antes de evaluar índice
    ldr w19, [x29, #544]
    ldr x20, [sp], #16  // Restaurar puntero del vector desde stack
    // Acceso a vector string: vector[index]
    add x22, x20, #8             // saltar header (4) + padding (4)
    add x22, x22, w19, uxtw #3   // calcular dirección: vector + index * 8
    ldr x21, [x22]               // cargar elemento string del vector
    mov x0, x21
    mov x1, x0
    ldr x0, [sp], #16
    // Concatenar string + string usando runtime C
    bl concat_string_string      // Llama a función C optimizada
    str x0, [sp, #-16]!
    adrp x19, str_lit_127
    add x19, x19, :lo12:str_lit_127
    mov x0, x19
    mov x1, x0
    ldr x0, [sp], #16
    // Concatenar string + string usando runtime C
    bl concat_string_string      // Llama a función C optimizada
    bl print_string
    adrp x0, newline_128
    add x0, x0, :lo12:newline_128
    bl print_string
    // Inicialización del for
    mov w19, #0
    str w19, [x29, #552]      // Guardar int 'periodo' en stack
for_start_16:  // Inicio del for
    ldr w19, [x29, #552]
    str w19, [sp, #-16]!         // Guardar primer operando en stack
    // Cargar puntero de matriz desde stack
    ldr x20, [x29, #304]
    str x20, [sp, #-16]!  // Preservar puntero matriz antes de evaluar índice fila
    ldr w21, [x29, #536]
    ldr x20, [sp], #16  // Restaurar puntero matriz desde stack
    // Acceso a fila: fila_ptr = matriz[fila]
    add x22, x20, #8             // saltar header de longitud
    add x22, x22, w21, uxtw #3   // offset = fila * 8
    ldr x22, [x22]               // cargar puntero de fila
    str x22, [sp, #-16]!  // Preservar puntero fila antes de evaluar índice columna
    ldr w23, [x29, #544]
    ldr x22, [sp], #16  // Restaurar puntero fila desde stack
    // Acceso a elemento: resultado = fila[columna]
    add x24, x22, #8             // saltar header de fila
    add x24, x24, w23, uxtw #3   // addr = fila_ptr + columna * 8
    ldr x25, [x24]               // cargar elemento desde addr
    // Array.length: cargar longitud del array
    ldr w19, [x25, #0]        // longitud = array[0] (4 bytes)
    ldr w20, [sp], #16           // Restaurar primer operando desde stack
    // Comparación INT: w20 < w19 usando runtime C
    mov w0, w20
    mov w1, w19
    bl cmp_int_lt
    // Convertir resultado string a booleano
    bl string_to_boolean
    // w0 ahora contiene 0 (false) o 1 (true)
    cbz w0, for_end_16  // Si condición es falsa, salir del for
    // Cargar puntero de array multidimensional desde stack
    ldr x19, [x29, #304]
    ldr w20, [x29, #536]
    // Nivel 0: Navegar a sub-array
    add x21, x19, #8             // Saltar header (length + remaining_dims)
    add x21, x21, w20, uxtw #3   // offset = index * 8 (punteros)
    ldr x21, [x21]               // Cargar puntero a sub-array
    ldr w20, [x29, #544]
    // Nivel 1: Navegar a sub-array
    add x22, x21, #8             // Saltar header (length + remaining_dims)
    add x22, x22, w20, uxtw #3   // offset = index * 8 (punteros)
    ldr x22, [x22]               // Cargar puntero a sub-array
    ldr w20, [x29, #552]
    // Nivel final: Leer valor
    add x21, x22, #8             // Saltar header del array de datos
    add x21, x21, w20, uxtw #3  // addr = ptr + index * element_size
    ldr d23, [x21]               // Cargar valor
    str d23, [x29, #560]      // Guardar double 'temp' en stack
    adrp x20, str_lit_129
    add x20, x20, :lo12:str_lit_129
    mov x0, x20
    str x0, [sp, #-16]!
    // Cargar puntero del array desde stack
    ldr x19, [x29, #512]      // cargar puntero del array desde stack
    str x19, [sp, #-16]!  // Preservar puntero vector antes de evaluar índice
    ldr w19, [x29, #552]
    ldr x20, [sp], #16  // Restaurar puntero del vector desde stack
    // Acceso a vector string: vector[index]
    add x22, x20, #8             // saltar header (4) + padding (4)
    add x22, x22, w19, uxtw #3   // calcular dirección: vector + index * 8
    ldr x21, [x22]               // cargar elemento string del vector
    mov x0, x21
    mov x1, x0
    ldr x0, [sp], #16
    // Concatenar string + string usando runtime C
    bl concat_string_string      // Llama a función C optimizada
    str x0, [sp, #-16]!
    adrp x19, str_lit_130
    add x19, x19, :lo12:str_lit_130
    mov x0, x19
    mov x1, x0
    ldr x0, [sp], #16
    // Concatenar string + string usando runtime C
    bl concat_string_string      // Llama a función C optimizada
    str x0, [sp, #-16]!
    ldr d0, [x29, #560]
    // Preservar d0 antes de malloc
    str d0, [x29, #16]                // Guardar double en stack temporal
    // String.valueOf() - Reservar buffer para resultado
    mov x0, #64                      // Tamaño del buffer
    bl malloc                         // Llamar a malloc
    str x0, [x29, #24]               // Guardar puntero al buffer en stack temporal (#24)
    // String.valueOf(double)
    ldr d0, [x29, #16]            // Cargar double desde stack temporal
    bl format_double              // Llamar a runtime C (argumento en d0)
    str x0, [x29, #24]            // Guardar resultado en stack (#24)
    ldr x21, [x29, #24]             // Cargar buffer desde stack
    mov x19, x21                      // Mover resultado a x19
    mov x0, x19
    mov x1, x0
    ldr x0, [sp], #16
    // Concatenar string + string usando runtime C
    bl concat_string_string      // Llama a función C optimizada
    str x0, [sp, #-16]!
    adrp x19, str_lit_131
    add x19, x19, :lo12:str_lit_131
    mov x0, x19
    mov x1, x0
    ldr x0, [sp], #16
    // Concatenar string + string usando runtime C
    bl concat_string_string      // Llama a función C optimizada
    bl print_string
    adrp x0, newline_132
    add x0, x0, :lo12:newline_132
    bl print_string
for_continue_16:  // Continue del for (actualización)
    // Actualización del for
    ldr w19, [x29, #552]
    str w19, [x29, #568]  // Preservar operando izq (prof=0)
    mov w20, #1
    ldr w19, [x29, #568]  // Restaurar operando izq (prof=0)
    add w21, w19, w20
    str w21, [x29, #552]      // Guardar int 'periodo' en stack
    b for_start_16  // Volver al inicio del for
for_end_16:  // Fin del for
for_continue_15:  // Continue del for (actualización)
    // Actualización del for
    ldr w19, [x29, #544]
    str w19, [x29, #568]  // Preservar operando izq (prof=0)
    mov w20, #1
    ldr w19, [x29, #568]  // Restaurar operando izq (prof=0)
    add w21, w19, w20
    str w21, [x29, #544]      // Guardar int 'dia' en stack
    b for_start_15  // Volver al inicio del for
for_end_15:  // Fin del for
for_continue_14:  // Continue del for (actualización)
    // Actualización del for
    ldr w19, [x29, #536]
    str w19, [x29, #568]  // Preservar operando izq (prof=0)
    mov w20, #1
    ldr w19, [x29, #568]  // Restaurar operando izq (prof=0)
    add w21, w19, w20
    str w21, [x29, #536]      // Guardar int 'semana' en stack
    b for_start_14  // Volver al inicio del for
for_end_14:  // Fin del for
    adrp x19, str_lit_133
    add x19, x19, :lo12:str_lit_133
    mov x0, x19
    bl print_string
    adrp x0, newline_134
    add x0, x0, :lo12:newline_134
    bl print_string
    adrp x19, str_lit_135
    add x19, x19, :lo12:str_lit_135
    mov x0, x19
    bl print_string
    adrp x0, newline_136
    add x0, x0, :lo12:newline_136
    bl print_string

    // Preparar argumentos para llamada
    ldr x19, [x29, #200]      // Cargar puntero del array 'matrizA' desde stack
    mov x0, x19                // Mover puntero a registro argumento
    bl mostrarMatriz                       // Llamar función
    adrp x20, str_lit_137
    add x20, x20, :lo12:str_lit_137
    mov x0, x20
    bl print_string
    adrp x0, newline_138
    add x0, x0, :lo12:newline_138
    bl print_string

    // Preparar argumentos para llamada
    ldr x20, [x29, #224]      // Cargar puntero del array 'matrizB' desde stack
    mov x0, x20                // Mover puntero a registro argumento
    bl mostrarMatriz                       // Llamar función

    // Preparar argumentos para llamada
    ldr x21, [x29, #200]      // Cargar puntero del array 'matrizA' desde stack
    mov x0, x21                // Mover puntero a registro argumento
    ldr x22, [x29, #224]      // Cargar puntero del array 'matrizB' desde stack
    mov x1, x22                // Mover puntero a registro argumento
    bl sumarMatrices                       // Llamar función
    str x0, [x29, #568]      // Guardar vector 'matrizSuma' en stack
    adrp x23, str_lit_139
    add x23, x23, :lo12:str_lit_139
    mov x0, x23
    bl print_string
    adrp x0, newline_140
    add x0, x0, :lo12:newline_140
    bl print_string

    // Preparar argumentos para llamada
    ldr x23, [x29, #568]      // Cargar puntero del array 'matrizSuma' desde stack
    mov x0, x23                // Mover puntero a registro argumento
    bl mostrarMatriz                       // Llamar función

    // Preparar argumentos para llamada
    ldr x24, [x29, #200]      // Cargar puntero del array 'matrizA' desde stack
    mov x0, x24                // Mover puntero a registro argumento
    ldr x25, [x29, #224]      // Cargar puntero del array 'matrizB' desde stack
    mov x1, x25                // Mover puntero a registro argumento
    bl multiplicarMatrices                       // Llamar función
    str x0, [x29, #576]      // Guardar vector 'matrizProducto' en stack
    adrp x26, str_lit_141
    add x26, x26, :lo12:str_lit_141
    mov x0, x26
    bl print_string
    adrp x0, newline_142
    add x0, x0, :lo12:newline_142
    bl print_string

    // Preparar argumentos para llamada
    ldr x26, [x29, #576]      // Cargar puntero del array 'matrizProducto' desde stack
    mov x0, x26                // Mover puntero a registro argumento
    bl mostrarMatriz                       // Llamar función
    adrp x27, str_lit_143
    add x27, x27, :lo12:str_lit_143
    mov x0, x27
    bl print_string
    adrp x0, newline_144
    add x0, x0, :lo12:newline_144
    bl print_string
    adrp x27, str_lit_145
    add x27, x27, :lo12:str_lit_145
    mov x0, x27
    bl print_string
    adrp x0, newline_146
    add x0, x0, :lo12:newline_146
    bl print_string
    adrp x27, str_lit_147
    add x27, x27, :lo12:str_lit_147
    mov x0, x27
    bl print_string
    adrp x0, newline_148
    add x0, x0, :lo12:newline_148
    bl print_string
    adrp x27, str_lit_149
    add x27, x27, :lo12:str_lit_149
    mov x0, x27
    bl print_string
    adrp x0, newline_150
    add x0, x0, :lo12:newline_150
    bl print_string
    // Crear matriz con lista de elementos
    mov x0, #32               // 8 (header) + 3 filas * 8 bytes
    bl malloc
    mov x27, x0               // guardar puntero del array de filas
    mov x23, #3              // número de filas
    str x23, [x27]            // guardar longitud en header
    // Crear fila 0 (con header de 8 bytes)
    mov x0, #24               // 8 (header) + 4 elementos
    bl malloc
    mov x28, x0
    mov w9, #4              // número de elementos
    str w9, [x28]            // guardar longitud en header de fila (4 bytes)
    mov w9, #1
    str w9, [x28, #8]
    mov w9, #2
    str w9, [x28, #12]
    mov w9, #3
    str w9, [x28, #16]
    mov w9, #4
    str w9, [x28, #20]
    str x28, [x27, #8]       // matriz[0] = fila
    // Crear fila 1 (con header de 8 bytes)
    mov x0, #24               // 8 (header) + 4 elementos
    bl malloc
    mov x28, x0
    mov w9, #4              // número de elementos
    str w9, [x28]            // guardar longitud en header de fila (4 bytes)
    mov w9, #5
    str w9, [x28, #8]
    mov w9, #6
    str w9, [x28, #12]
    mov w9, #7
    str w9, [x28, #16]
    mov w9, #8
    str w9, [x28, #20]
    str x28, [x27, #16]       // matriz[1] = fila
    // Crear fila 2 (con header de 8 bytes)
    mov x0, #24               // 8 (header) + 4 elementos
    bl malloc
    mov x28, x0
    mov w9, #4              // número de elementos
    str w9, [x28]            // guardar longitud en header de fila (4 bytes)
    mov w9, #9
    str w9, [x28, #8]
    mov w9, #10
    str w9, [x28, #12]
    mov w9, #11
    str w9, [x28, #16]
    mov w9, #12
    str w9, [x28, #20]
    str x28, [x27, #24]       // matriz[2] = fila
    // Almacenar matriz en stack
    str x27, [x29, #584]
    adrp x27, str_lit_151
    add x27, x27, :lo12:str_lit_151
    mov x0, x27
    bl print_string
    adrp x0, newline_152
    add x0, x0, :lo12:newline_152
    bl print_string

    // Preparar argumentos para llamada
    ldr x27, [x29, #584]      // Cargar puntero del array 'matrizRectangular' desde stack
    mov x0, x27                // Mover puntero a registro argumento
    bl mostrarMatriz                       // Llamar función

    // Preparar argumentos para llamada
    ldr x28, [x29, #584]      // Cargar puntero del array 'matrizRectangular' desde stack
    mov x0, x28                // Mover puntero a registro argumento
    bl calcularTranspuesta                       // Llamar función
    str x0, [x29, #608]      // Guardar vector 'matrizTranspuesta' en stack
    adrp x9, str_lit_153
    add x9, x9, :lo12:str_lit_153
    mov x0, x9
    bl print_string
    adrp x0, newline_154
    add x0, x0, :lo12:newline_154
    bl print_string

    // Preparar argumentos para llamada
    ldr x9, [x29, #608]      // Cargar puntero del array 'matrizTranspuesta' desde stack
    mov x0, x9                // Mover puntero a registro argumento
    bl mostrarMatriz                       // Llamar función
    adrp x10, str_lit_155
    add x10, x10, :lo12:str_lit_155
    mov x0, x10
    bl print_string
    adrp x0, newline_156
    add x0, x0, :lo12:newline_156
    bl print_string

    // Preparar argumentos para llamada
    ldr x10, [x29, #200]      // Cargar puntero del array 'matrizA' desde stack
    mov x0, x10                // Mover puntero a registro argumento
    bl calcularTranspuesta                       // Llamar función
    str x0, [x29, #616]      // Guardar vector 'transpuestaA' en stack

    // Preparar argumentos para llamada
    ldr x11, [x29, #616]      // Cargar puntero del array 'transpuestaA' desde stack
    mov x0, x11                // Mover puntero a registro argumento
    bl mostrarMatriz                       // Llamar función

    // Preparar argumentos para llamada
    ldr x12, [x29, #616]      // Cargar puntero del array 'transpuestaA' desde stack
    mov x0, x12                // Mover puntero a registro argumento
    bl calcularTranspuesta                       // Llamar función
    str x0, [x29, #624]      // Guardar vector 'dobleTranspuesta' en stack
    adrp x13, str_lit_157
    add x13, x13, :lo12:str_lit_157
    mov x0, x13
    bl print_string
    adrp x0, newline_158
    add x0, x0, :lo12:newline_158
    bl print_string

    // Preparar argumentos para llamada
    ldr x13, [x29, #624]      // Cargar puntero del array 'dobleTranspuesta' desde stack
    mov x0, x13                // Mover puntero a registro argumento
    bl mostrarMatriz                       // Llamar función
    adrp x14, str_lit_159
    add x14, x14, :lo12:str_lit_159
    mov x0, x14
    bl print_string
    adrp x0, newline_160
    add x0, x0, :lo12:newline_160
    bl print_string
    // Crear matriz con lista de elementos
    mov x0, #24               // 8 (header) + 2 filas * 8 bytes
    bl malloc
    mov x14, x0               // guardar puntero del array de filas
    mov x23, #2              // número de filas
    str x23, [x14]            // guardar longitud en header
    // Crear fila 0 (con header de 8 bytes)
    mov x0, #16               // 8 (header) + 2 elementos
    bl malloc
    mov x15, x0
    mov w19, #2              // número de elementos
    str w19, [x15]            // guardar longitud en header de fila (4 bytes)
    mov w19, #4
    str w19, [x15, #8]
    mov w19, #3
    str w19, [x15, #12]
    str x15, [x14, #8]       // matriz[0] = fila
    // Crear fila 1 (con header de 8 bytes)
    mov x0, #16               // 8 (header) + 2 elementos
    bl malloc
    mov x19, x0
    mov w20, #2              // número de elementos
    str w20, [x19]            // guardar longitud en header de fila (4 bytes)
    mov w20, #2
    str w20, [x19, #8]
    mov w20, #1
    str w20, [x19, #12]
    str x19, [x14, #16]       // matriz[1] = fila
    // Almacenar matriz en stack
    str x14, [x29, #632]
    adrp x19, str_lit_161
    add x19, x19, :lo12:str_lit_161
    mov x0, x19
    bl print_string
    adrp x0, newline_162
    add x0, x0, :lo12:newline_162
    bl print_string

    // Preparar argumentos para llamada
    ldr x19, [x29, #632]      // Cargar puntero del array 'matriz2x2' desde stack
    mov x0, x19                // Mover puntero a registro argumento
    bl mostrarMatriz                       // Llamar función

    // Preparar argumentos para llamada
    ldr x20, [x29, #632]      // Cargar puntero del array 'matriz2x2' desde stack
    mov x0, x20                // Mover puntero a registro argumento
    bl calcularDeterminante2x2                       // Llamar función
    str w0, [x29, #656]      // Guardar int 'determinante2x2' en stack
    adrp x21, str_lit_163
    add x21, x21, :lo12:str_lit_163
    mov x0, x21
    str x0, [sp, #-16]!
    ldr w19, [x29, #656]
    // String.valueOf() - Reservar buffer para resultado
    mov x0, #64                      // Tamaño del buffer
    bl malloc                         // Llamar a malloc
    str x0, [x29, #24]               // Guardar puntero al buffer en stack temporal (#24)
    // String.valueOf(int)
    ldr x0, [x29, #24]             // Cargar buffer desde stack
    mov x1, #64                   // tamaño del buffer
    adrp x2, .Lfmt_int            // Formato %d
    add x2, x2, :lo12:.Lfmt_int
    mov w3, w19                   // Valor int a convertir
    bl snprintf
    ldr x21, [x29, #24]             // Cargar buffer desde stack
    mov x19, x21                      // Mover resultado a x19
    mov x0, x19
    mov x1, x0
    ldr x0, [sp], #16
    // Concatenar string + string usando runtime C
    bl concat_string_string      // Llama a función C optimizada
    bl print_string
    adrp x0, newline_164
    add x0, x0, :lo12:newline_164
    bl print_string
    // Crear matriz con lista de elementos
    mov x0, #24               // 8 (header) + 2 filas * 8 bytes
    bl malloc
    mov x19, x0               // guardar puntero del array de filas
    mov x23, #2              // número de filas
    str x23, [x19]            // guardar longitud en header
    // Crear fila 0 (con header de 8 bytes)
    mov x0, #16               // 8 (header) + 2 elementos
    bl malloc
    mov x20, x0
    mov w21, #2              // número de elementos
    str w21, [x20]            // guardar longitud en header de fila (4 bytes)
    mov w21, #5
    str w21, [x20, #8]
    mov w21, #2
    str w21, [x20, #12]
    str x20, [x19, #8]       // matriz[0] = fila
    // Crear fila 1 (con header de 8 bytes)
    mov x0, #16               // 8 (header) + 2 elementos
    bl malloc
    mov x20, x0
    mov w21, #2              // número de elementos
    str w21, [x20]            // guardar longitud en header de fila (4 bytes)
    mov w21, #3
    str w21, [x20, #8]
    mov w21, #4
    str w21, [x20, #12]
    str x20, [x19, #16]       // matriz[1] = fila
    // Almacenar matriz en stack
    str x19, [x29, #664]
    adrp x19, str_lit_165
    add x19, x19, :lo12:str_lit_165
    mov x0, x19
    bl print_string
    adrp x0, newline_166
    add x0, x0, :lo12:newline_166
    bl print_string

    // Preparar argumentos para llamada
    ldr x19, [x29, #664]      // Cargar puntero del array 'matriz2x2_2' desde stack
    mov x0, x19                // Mover puntero a registro argumento
    bl mostrarMatriz                       // Llamar función

    // Preparar argumentos para llamada
    ldr x20, [x29, #664]      // Cargar puntero del array 'matriz2x2_2' desde stack
    mov x0, x20                // Mover puntero a registro argumento
    bl calcularDeterminante2x2                       // Llamar función
    str w0, [x29, #688]      // Guardar int 'det2x2_2' en stack
    adrp x21, str_lit_167
    add x21, x21, :lo12:str_lit_167
    mov x0, x21
    str x0, [sp, #-16]!
    ldr w19, [x29, #688]
    // String.valueOf() - Reservar buffer para resultado
    mov x0, #64                      // Tamaño del buffer
    bl malloc                         // Llamar a malloc
    str x0, [x29, #24]               // Guardar puntero al buffer en stack temporal (#24)
    // String.valueOf(int)
    ldr x0, [x29, #24]             // Cargar buffer desde stack
    mov x1, #64                   // tamaño del buffer
    adrp x2, .Lfmt_int            // Formato %d
    add x2, x2, :lo12:.Lfmt_int
    mov w3, w19                   // Valor int a convertir
    bl snprintf
    ldr x21, [x29, #24]             // Cargar buffer desde stack
    mov x19, x21                      // Mover resultado a x19
    mov x0, x19
    mov x1, x0
    ldr x0, [sp], #16
    // Concatenar string + string usando runtime C
    bl concat_string_string      // Llama a función C optimizada
    bl print_string
    adrp x0, newline_168
    add x0, x0, :lo12:newline_168
    bl print_string
    adrp x19, str_lit_169
    add x19, x19, :lo12:str_lit_169
    mov x0, x19
    bl print_string
    adrp x0, newline_170
    add x0, x0, :lo12:newline_170
    bl print_string

    // Preparar argumentos para llamada
    ldr x19, [x29, #200]      // Cargar puntero del array 'matrizA' desde stack
    mov x0, x19                // Mover puntero a registro argumento
    bl mostrarMatriz                       // Llamar función

    // Preparar argumentos para llamada
    ldr x20, [x29, #200]      // Cargar puntero del array 'matrizA' desde stack
    mov x0, x20                // Mover puntero a registro argumento
    bl calcularDeterminante3x3                       // Llamar función
    str w0, [x29, #696]      // Guardar int 'determinante3x3' en stack
    adrp x21, str_lit_171
    add x21, x21, :lo12:str_lit_171
    mov x0, x21
    str x0, [sp, #-16]!
    ldr w19, [x29, #696]
    // String.valueOf() - Reservar buffer para resultado
    mov x0, #64                      // Tamaño del buffer
    bl malloc                         // Llamar a malloc
    str x0, [x29, #24]               // Guardar puntero al buffer en stack temporal (#24)
    // String.valueOf(int)
    ldr x0, [x29, #24]             // Cargar buffer desde stack
    mov x1, #64                   // tamaño del buffer
    adrp x2, .Lfmt_int            // Formato %d
    add x2, x2, :lo12:.Lfmt_int
    mov w3, w19                   // Valor int a convertir
    bl snprintf
    ldr x21, [x29, #24]             // Cargar buffer desde stack
    mov x19, x21                      // Mover resultado a x19
    mov x0, x19
    mov x1, x0
    ldr x0, [sp], #16
    // Concatenar string + string usando runtime C
    bl concat_string_string      // Llama a función C optimizada
    bl print_string
    adrp x0, newline_172
    add x0, x0, :lo12:newline_172
    bl print_string
    // Crear matriz con lista de elementos
    mov x0, #32               // 8 (header) + 3 filas * 8 bytes
    bl malloc
    mov x19, x0               // guardar puntero del array de filas
    mov x23, #3              // número de filas
    str x23, [x19]            // guardar longitud en header
    // Crear fila 0 (con header de 8 bytes)
    mov x0, #20               // 8 (header) + 3 elementos
    bl malloc
    mov x20, x0
    mov w21, #3              // número de elementos
    str w21, [x20]            // guardar longitud en header de fila (4 bytes)
    mov w21, #2
    str w21, [x20, #8]
    mov w21, #1
    neg w0, w21              // Negar entero
    str w0, [x20, #12]
    mov w21, #3
    str w21, [x20, #16]
    str x20, [x19, #8]       // matriz[0] = fila
    // Crear fila 1 (con header de 8 bytes)
    mov x0, #20               // 8 (header) + 3 elementos
    bl malloc
    mov x20, x0
    mov w21, #3              // número de elementos
    str w21, [x20]            // guardar longitud en header de fila (4 bytes)
    mov w21, #1
    str w21, [x20, #8]
    mov w21, #0
    str w21, [x20, #12]
    mov w21, #1
    str w21, [x20, #16]
    str x20, [x19, #16]       // matriz[1] = fila
    // Crear fila 2 (con header de 8 bytes)
    mov x0, #20               // 8 (header) + 3 elementos
    bl malloc
    mov x20, x0
    mov w21, #3              // número de elementos
    str w21, [x20]            // guardar longitud en header de fila (4 bytes)
    mov w21, #1
    str w21, [x20, #8]
    mov w21, #2
    str w21, [x20, #12]
    mov w21, #1
    neg w0, w21              // Negar entero
    str w0, [x20, #16]
    str x20, [x19, #24]       // matriz[2] = fila
    // Almacenar matriz en stack
    str x19, [x29, #704]
    adrp x19, str_lit_173
    add x19, x19, :lo12:str_lit_173
    mov x0, x19
    bl print_string
    adrp x0, newline_174
    add x0, x0, :lo12:newline_174
    bl print_string

    // Preparar argumentos para llamada
    ldr x19, [x29, #704]      // Cargar puntero del array 'matriz3x3_especial' desde stack
    mov x0, x19                // Mover puntero a registro argumento
    bl mostrarMatriz                       // Llamar función

    // Preparar argumentos para llamada
    ldr x20, [x29, #704]      // Cargar puntero del array 'matriz3x3_especial' desde stack
    mov x0, x20                // Mover puntero a registro argumento
    bl calcularDeterminante3x3                       // Llamar función
    str w0, [x29, #728]      // Guardar int 'det3x3_especial' en stack
    adrp x21, str_lit_175
    add x21, x21, :lo12:str_lit_175
    mov x0, x21
    str x0, [sp, #-16]!
    ldr w19, [x29, #728]
    // String.valueOf() - Reservar buffer para resultado
    mov x0, #64                      // Tamaño del buffer
    bl malloc                         // Llamar a malloc
    str x0, [x29, #24]               // Guardar puntero al buffer en stack temporal (#24)
    // String.valueOf(int)
    ldr x0, [x29, #24]             // Cargar buffer desde stack
    mov x1, #64                   // tamaño del buffer
    adrp x2, .Lfmt_int            // Formato %d
    add x2, x2, :lo12:.Lfmt_int
    mov w3, w19                   // Valor int a convertir
    bl snprintf
    ldr x21, [x29, #24]             // Cargar buffer desde stack
    mov x19, x21                      // Mover resultado a x19
    mov x0, x19
    mov x1, x0
    ldr x0, [sp], #16
    // Concatenar string + string usando runtime C
    bl concat_string_string      // Llama a función C optimizada
    bl print_string
    adrp x0, newline_176
    add x0, x0, :lo12:newline_176
    bl print_string
    adrp x19, str_lit_177
    add x19, x19, :lo12:str_lit_177
    mov x0, x19
    bl print_string
    adrp x0, newline_178
    add x0, x0, :lo12:newline_178
    bl print_string
    mov w0, #0
    ldp x29, x30, [sp]            // Restaurar FP/LR
    add sp, sp, #4095
    add sp, sp, #1505
    bl exit
